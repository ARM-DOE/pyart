
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>pyart.retrieve.kdp_proc &#8212; Py-ART 0.0.0 documentation</title>
    
  <!-- Loaded before other Sphinx assets -->
  <link href="../../../_static/styles/theme.css?digest=1999514e3f237ded88cf" rel="stylesheet">
<link href="../../../_static/styles/pydata-sphinx-theme.css?digest=1999514e3f237ded88cf" rel="stylesheet">

    
  <link rel="stylesheet"
    href="../../../_static/vendor/fontawesome/5.13.0/css/all.min.css">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="../../../_static/vendor/fontawesome/5.13.0/webfonts/fa-solid-900.woff2">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="../../../_static/vendor/fontawesome/5.13.0/webfonts/fa-brands-400.woff2">

    <link rel="stylesheet" type="text/css" href="../../../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/plot_directive.css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/copybutton.css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/mystnb.css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/togglebutton.css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/sg_gallery.css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/sg_gallery.css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/sg_gallery-binder.css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/sg_gallery-dataframe.css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/sg_gallery-rendered-html.css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/pyart-theme.css" />
    
  <!-- Pre-loaded scripts that we'll load fully later -->
  <link rel="preload" as="script" href="../../../_static/scripts/pydata-sphinx-theme.js?digest=1999514e3f237ded88cf">

    <script data-url_root="../../../" id="documentation_options" src="../../../_static/documentation_options.js"></script>
    <script src="../../../_static/jquery.js"></script>
    <script src="../../../_static/underscore.js"></script>
    <script src="../../../_static/doctools.js"></script>
    <script src="../../../_static/clipboard.min.js"></script>
    <script src="../../../_static/copybutton.js"></script>
    <script>let toggleHintShow = 'Click to show';</script>
    <script>let toggleHintHide = 'Click to hide';</script>
    <script>let toggleOpenOnPrint = 'true';</script>
    <script src="../../../_static/togglebutton.js"></script>
    <script>var togglebuttonSelector = '.toggle, .admonition.dropdown, .tag_hide_input div.cell_input, .tag_hide-input div.cell_input, .tag_hide_output div.cell_output, .tag_hide-output div.cell_output, .tag_hide_cell.cell, .tag_hide-cell.cell';</script>
    <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
    <script src="../../../_static/doc_shared.js"></script>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" /> 
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="docsearch:language" content="None">
    

    <!-- Google Analytics -->
    
<script async="" src="https://www.googletagmanager.com/gtag/js?id=G-JJEG3CV376"></script>
<script>
                    window.dataLayer = window.dataLayer || [];
                    function gtag(){ dataLayer.push(arguments); }
                    gtag('js', new Date());
                    gtag('config', 'G-JJEG3CV376');
                </script>
 
<link
  rel="alternate"
  type="application/atom+xml"
  href="../../../blog/atom.xml"
  title="PyART Blog"
/>
 
<style type="text/css">
  ul.ablog-archive {
    list-style: none;
    overflow: auto;
    margin-left: 0px;
  }
  ul.ablog-archive li {
    float: left;
    margin-right: 5px;
    font-size: 80%;
  }
  ul.postlist a {
    font-style: italic;
  }
  ul.postlist-style-disc {
    list-style-type: disc;
  }
  ul.postlist-style-none {
    list-style-type: none;
  }
  ul.postlist-style-circle {
    list-style-type: circle;
  }
</style>

  </head>
  <body data-spy="scroll" data-target="#bd-toc-nav" data-offset="60">
    
    <div class="container-fluid" id="banner"></div>

    
  <nav class="navbar navbar-dark navbar-expand-lg bg-arm fixed-top bd-navbar shadow" id="navbar-main"><div class="container-xl">

  <div id="navbar-start">
    
    
<a class="navbar-brand" href="../../../index.html">
<p class="title">Py-ART</p>
</a>

    
  </div>

  <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbar-collapsible" aria-controls="navbar-collapsible" aria-expanded="false" aria-label="Toggle navigation">
    <span class="navbar-toggler-icon"></span>
  </button>

  
  <div id="navbar-collapsible" class="col-lg-9 collapse navbar-collapse">
    <div id="navbar-center" class="mr-auto">
      
      <div class="navbar-center-item">
        <ul id="navbar-main-elements" class="navbar-nav">
    <li class="toctree-l1 nav-item">
 <a class="reference internal nav-link" href="../../../userguide/index.html">
  User Guide
 </a>
</li>

<li class="toctree-l1 nav-item">
 <a class="reference internal nav-link" href="../../../API/index.html">
  API Reference Manual
 </a>
</li>

<li class="toctree-l1 nav-item">
 <a class="reference internal nav-link" href="../../../examples/index.html">
  Example Gallery
 </a>
</li>

<li class="toctree-l1 nav-item">
 <a class="reference internal nav-link" href="../../../notebook-gallery.html">
  Notebook Gallery
 </a>
</li>

<li class="toctree-l1 nav-item">
 <a class="reference internal nav-link" href="../../../blog.html">
  Blog
 </a>
</li>

<li class="toctree-l1 nav-item">
 <a class="reference internal nav-link" href="../../../changelog.html">
  Changelog
 </a>
</li>

    
</ul>
      </div>
      
    </div>

    <div id="navbar-end">
      
      <div class="navbar-end-item">
        <ul id="navbar-icon-links" class="navbar-nav" aria-label="Icon Links">
        <li class="nav-item">
          <a class="nav-link" href="https://github.com/ARM-DOE/pyart" rel="noopener" target="_blank" title="GitHub"><span><i class="fab fa-github-square"></i></span>
            <label class="sr-only">GitHub</label></a>
        </li>
        <li class="nav-item">
          <a class="nav-link" href="https://twitter.com/Py_ART" rel="noopener" target="_blank" title="Twitter"><span><i class="fab fa-twitter-square"></i></span>
            <label class="sr-only">Twitter</label></a>
        </li>
      </ul>
      </div>
      
    </div>
  </div>
</div>
  </nav>


    <div class="container-fluid" id="banner"></div>


    <div class="container-xl">
      <div class="row">
          
            
            <!-- Only show if we have sidebars configured, else just a small margin  -->
            <div class="col-12 col-md-3 bd-sidebar">
              <div class="sidebar-start-items"><form class="bd-search d-flex align-items-center" action="../../../search.html" method="get">
  <i class="icon fas fa-search"></i>
  <input type="search" class="form-control" name="q" id="search-input" placeholder="Search the docs ..." aria-label="Search the docs ..." autocomplete="off" >
</form><nav class="bd-links" id="bd-docs-nav" aria-label="Main navigation">
  <div class="bd-toc-item active">
    
  </div>
</nav>
              </div>
              <div class="sidebar-end-items">
              </div>
            </div>
            
          

          
          <div class="d-none d-xl-block col-xl-2 bd-toc">
            
          </div>
          

          
          
            
          
          <main class="col-12 col-md-9 col-xl-7 py-md-5 pl-md-5 pr-md-4 bd-content" role="main">
              
              <div>
                 <h1>Source code for pyart.retrieve.kdp_proc</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Module for retrieving specific differential phase (KDP) from radar total</span>
<span class="sd">differential phase (PSIDP) measurements. Total differential phase is a function</span>
<span class="sd">of propagation differential phase (PHIDP), backscatter differential phase</span>
<span class="sd">(DELTAHV), and the system phase offset.</span>

<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">from</span> <span class="nn">functools</span> <span class="kn">import</span> <span class="n">partial</span>
<span class="kn">import</span> <span class="nn">time</span>
<span class="kn">import</span> <span class="nn">warnings</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">from</span> <span class="nn">scipy</span> <span class="kn">import</span> <span class="n">optimize</span><span class="p">,</span> <span class="n">stats</span><span class="p">,</span> <span class="n">interpolate</span><span class="p">,</span> <span class="n">linalg</span><span class="p">,</span> <span class="n">signal</span>

<span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">_kdp_proc</span>
<span class="kn">from</span> <span class="nn">..config</span> <span class="kn">import</span> <span class="n">get_field_name</span><span class="p">,</span> <span class="n">get_metadata</span><span class="p">,</span> <span class="n">get_fillvalue</span>
<span class="kn">from</span> <span class="nn">..util</span> <span class="kn">import</span> <span class="n">rolling_window</span>


<span class="c1"># Constants in the Kalman filter retrieval method (generally no need to</span>
<span class="c1"># modify them)</span>
<span class="n">SCALERS</span> <span class="o">=</span> <span class="p">[</span><span class="mf">0.1</span><span class="p">,</span> <span class="mi">10</span><span class="o">**</span><span class="p">(</span><span class="o">-</span><span class="mf">0.8</span><span class="p">),</span> <span class="mi">10</span><span class="o">**</span><span class="p">(</span><span class="o">-</span><span class="mf">0.6</span><span class="p">),</span> <span class="mi">10</span><span class="o">**</span><span class="p">(</span><span class="o">-</span><span class="mf">0.4</span><span class="p">),</span> <span class="mi">10</span><span class="o">**</span><span class="p">(</span><span class="o">-</span><span class="mf">0.2</span><span class="p">),</span> <span class="mi">1</span><span class="p">,</span>
           <span class="mi">10</span><span class="o">**</span><span class="p">(</span><span class="mf">0.2</span><span class="p">),</span> <span class="mi">10</span><span class="o">**</span><span class="p">(</span><span class="mf">0.4</span><span class="p">),</span> <span class="mi">10</span><span class="o">**</span><span class="p">(</span><span class="mf">0.6</span><span class="p">),</span> <span class="mi">10</span><span class="o">**</span><span class="p">(</span><span class="mf">0.8</span><span class="p">),</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">10</span><span class="p">]</span>

<span class="n">PADDING</span> <span class="o">=</span> <span class="mi">50</span>  <span class="c1"># Noise padding of the psidp signal (before and after signal)</span>
<span class="n">SHIFT</span> <span class="o">=</span> <span class="mi">13</span>  <span class="c1"># Shifting of the final signal</span>


<div class="viewcode-block" id="kdp_schneebeli"><a class="viewcode-back" href="../../../API/generated/pyart.retrieve.kdp_schneebeli.html#pyart.retrieve.kdp_schneebeli">[docs]</a><span class="k">def</span> <span class="nf">kdp_schneebeli</span><span class="p">(</span><span class="n">radar</span><span class="p">,</span> <span class="n">gatefilter</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">fill_value</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">psidp_field</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                   <span class="n">kdp_field</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">phidp_field</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">band</span><span class="o">=</span><span class="s1">&#39;C&#39;</span><span class="p">,</span> <span class="n">rcov</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">pcov</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
                   <span class="n">prefilter_psidp</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">filter_opt</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">parallel</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Estimates Kdp with the Kalman filter method by Schneebeli and al. (2014)</span>
<span class="sd">    for a set of psidp measurements.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    radar : Radar</span>
<span class="sd">        Radar containing differential phase field.</span>
<span class="sd">    gatefilter : GateFilter, optional</span>
<span class="sd">        A GateFilter indicating radar gates that should be excluded when</span>
<span class="sd">        analysing differential phase measurements.</span>
<span class="sd">    fill_value : float, optional</span>
<span class="sd">        Value indicating missing or bad data in differential phase field, if</span>
<span class="sd">        not specified, the default in the Py-ART configuration file will be</span>
<span class="sd">        used.</span>
<span class="sd">    psidp_field : str, optional</span>
<span class="sd">        Total differential phase field. If None, the default field name must be</span>
<span class="sd">        specified in the Py-ART configuration file.</span>
<span class="sd">    kdp_field : str, optional</span>
<span class="sd">        Specific differential phase field. If None, the default field name must</span>
<span class="sd">        be specified in the Py-ART configuration file.</span>
<span class="sd">    phidp_field : str, optional</span>
<span class="sd">        Propagation differential phase field. If None, the default field name</span>
<span class="sd">        must be specified in the Py-ART configuration file.</span>
<span class="sd">    band : char, optional</span>
<span class="sd">       Radar frequency band string. Accepted &quot;X&quot;, &quot;C&quot;, &quot;S&quot; (capital</span>
<span class="sd">       or not). The band is used to compute intercepts -c and slope b of the</span>
<span class="sd">       delta = b*Kdp+c relation.</span>
<span class="sd">    rcov : 3x3 float array, optional</span>
<span class="sd">        Measurement error covariance matrix.</span>
<span class="sd">    pcov : 4x4 float array, optional</span>
<span class="sd">        Scaled state transition error covariance matrix.</span>
<span class="sd">    prefilter_psidp : bool, optional</span>
<span class="sd">        If set, the psidp measurements will first be filtered with the</span>
<span class="sd">        filter_psidp method, which can improve the quality of the final Kdp.</span>
<span class="sd">    filter_opt : dict, optional</span>
<span class="sd">        The arguments for the prefilter_psidp method, if empty, the defaults</span>
<span class="sd">        arguments of this method will be used.</span>
<span class="sd">    parallel : bool, optional</span>
<span class="sd">        Flag to enable parallel computation (one core for every psidp profile).</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    kdp_dict : dict</span>
<span class="sd">        Retrieved specific differential phase data and metadata.</span>
<span class="sd">    kdp_std_dict : dict</span>
<span class="sd">        Estimated specific differential phase standard dev. data and metadata.</span>
<span class="sd">    phidpr_dict,: dict</span>
<span class="sd">        Retrieved differential phase data and metadata.</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    Schneebeli, M., Grazioli, J., and Berne, A.: Improved Estimation</span>
<span class="sd">    of the Specific Differential Phase SHIFT Using a Compilation of</span>
<span class="sd">    Kalman Filter Ensembles, IEEE T. Geosci. Remote Sens., 52,</span>
<span class="sd">    5137-5149, doi:10.1109/TGRS.2013.2287017, 2014.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># create parallel computing instance</span>
    <span class="k">if</span> <span class="n">parallel</span><span class="p">:</span>
        <span class="kn">import</span> <span class="nn">multiprocessing</span> <span class="k">as</span> <span class="nn">mp</span>

        <span class="n">pool</span> <span class="o">=</span> <span class="n">mp</span><span class="o">.</span><span class="n">Pool</span><span class="p">(</span><span class="n">processes</span><span class="o">=</span><span class="n">mp</span><span class="o">.</span><span class="n">cpu_count</span><span class="p">(),</span> <span class="n">maxtasksperchild</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

    <span class="c1"># parse fill value</span>
    <span class="k">if</span> <span class="n">fill_value</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">fill_value</span> <span class="o">=</span> <span class="n">get_fillvalue</span><span class="p">()</span>

    <span class="c1"># parse field names</span>
    <span class="k">if</span> <span class="n">psidp_field</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">psidp_field</span> <span class="o">=</span> <span class="n">get_field_name</span><span class="p">(</span><span class="s1">&#39;differential_phase&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">kdp_field</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">kdp_field</span> <span class="o">=</span> <span class="n">get_field_name</span><span class="p">(</span><span class="s1">&#39;specific_differential_phase&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">phidp_field</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">phidp_field</span> <span class="o">=</span> <span class="n">get_field_name</span><span class="p">(</span><span class="s1">&#39;differential_phase&#39;</span><span class="p">)</span>

    <span class="c1"># parse range resolution, length scale and low-pass filter constraint</span>
    <span class="c1"># weight</span>
    <span class="n">dr</span> <span class="o">=</span> <span class="n">_parse_range_resolution</span><span class="p">(</span><span class="n">radar</span><span class="p">,</span> <span class="n">check_uniform</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="c1"># parse total differential phase measurements</span>
    <span class="k">if</span> <span class="n">prefilter_psidp</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">filter_opt</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">filter_opt</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="c1"># Assign psidp field to filter_psidp inputs</span>
        <span class="n">filter_opt</span><span class="p">[</span><span class="s1">&#39;psidp_field&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">psidp_field</span>
        <span class="c1"># Filter psidp</span>
        <span class="n">psidp_o</span> <span class="o">=</span> <span class="n">filter_psidp</span><span class="p">(</span><span class="n">radar</span><span class="p">,</span> <span class="o">**</span><span class="n">filter_opt</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">psidp_o</span> <span class="o">=</span> <span class="n">radar</span><span class="o">.</span><span class="n">fields</span><span class="p">[</span><span class="n">psidp_field</span><span class="p">][</span><span class="s1">&#39;data&#39;</span><span class="p">]</span>

    <span class="c1"># mask radar gates indicated by the gate filter</span>
    <span class="k">if</span> <span class="n">gatefilter</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">psidp_o</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">masked_where</span><span class="p">(</span><span class="n">gatefilter</span><span class="o">.</span><span class="n">gate_excluded</span><span class="p">,</span> <span class="n">psidp_o</span><span class="p">)</span>

    <span class="n">func</span> <span class="o">=</span> <span class="n">partial</span><span class="p">(</span><span class="n">_kdp_kalman_profile</span><span class="p">,</span> <span class="n">dr</span><span class="o">=</span><span class="n">dr</span><span class="p">,</span> <span class="n">band</span><span class="o">=</span><span class="n">band</span><span class="p">,</span> <span class="n">rcov</span><span class="o">=</span><span class="n">rcov</span><span class="p">,</span>
                   <span class="n">pcov</span><span class="o">=</span><span class="n">pcov</span><span class="p">)</span>

    <span class="n">all_psidp_prof</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">psidp_o</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">parallel</span><span class="p">:</span>
        <span class="n">list_est</span> <span class="o">=</span> <span class="n">pool</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="n">all_psidp_prof</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">list_est</span> <span class="o">=</span> <span class="nb">map</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="n">all_psidp_prof</span><span class="p">)</span>

    <span class="n">kdp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">psidp_o</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
    <span class="n">kdp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">masked_array</span><span class="p">(</span><span class="n">kdp</span><span class="p">,</span> <span class="n">fill_value</span><span class="o">=</span><span class="n">fill_value</span><span class="p">)</span>

    <span class="n">kdp_stdev</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">psidp_o</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
    <span class="n">kdp_stdev</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">masked_array</span><span class="p">(</span><span class="n">kdp_stdev</span><span class="p">,</span> <span class="n">fill_value</span><span class="o">=</span><span class="n">fill_value</span><span class="p">)</span>

    <span class="n">phidp_rec</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">psidp_o</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
    <span class="n">phidp_rec</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">masked_array</span><span class="p">(</span><span class="n">phidp_rec</span><span class="p">,</span> <span class="n">fill_value</span><span class="o">=</span><span class="n">fill_value</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">l</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">list_est</span><span class="p">):</span>
        <span class="n">kdp</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="mi">0</span><span class="p">:</span><span class="nb">len</span><span class="p">(</span><span class="n">l</span><span class="p">[</span><span class="mi">0</span><span class="p">])]</span> <span class="o">=</span> <span class="n">l</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">kdp_stdev</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="mi">0</span><span class="p">:</span><span class="nb">len</span><span class="p">(</span><span class="n">l</span><span class="p">[</span><span class="mi">1</span><span class="p">])]</span> <span class="o">=</span> <span class="n">l</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">phidp_rec</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="mi">0</span><span class="p">:</span><span class="nb">len</span><span class="p">(</span><span class="n">l</span><span class="p">[</span><span class="mi">2</span><span class="p">])]</span> <span class="o">=</span> <span class="n">l</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>

    <span class="c1"># Mask the estimated Kdp and reconstructed Phidp with the mask of original</span>
    <span class="c1"># psidp</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">psidp_o</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">masked_array</span><span class="p">):</span>
        <span class="n">masked</span> <span class="o">=</span> <span class="n">psidp_o</span><span class="o">.</span><span class="n">mask</span>
        <span class="n">kdp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">kdp</span><span class="p">,</span> <span class="n">mask</span><span class="o">=</span><span class="n">masked</span><span class="p">,</span> <span class="n">fill_value</span><span class="o">=</span><span class="n">fill_value</span><span class="p">)</span>
        <span class="n">kdp_stdev</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">kdp_stdev</span><span class="p">,</span> <span class="n">mask</span><span class="o">=</span><span class="n">masked</span><span class="p">,</span> <span class="n">fill_value</span><span class="o">=</span><span class="n">fill_value</span><span class="p">)</span>
        <span class="n">phidp_rec</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">phidp_rec</span><span class="p">,</span> <span class="n">mask</span><span class="o">=</span><span class="n">masked</span><span class="p">,</span> <span class="n">fill_value</span><span class="o">=</span><span class="n">fill_value</span><span class="p">)</span>

    <span class="c1"># create specific differential phase field dictionary and store data</span>
    <span class="n">kdp_dict</span> <span class="o">=</span> <span class="n">get_metadata</span><span class="p">(</span><span class="n">kdp_field</span><span class="p">)</span>
    <span class="n">kdp_dict</span><span class="p">[</span><span class="s1">&#39;data&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">kdp</span>
    <span class="c1"># kdp_dict[&#39;valid_min&#39;] = -1.0</span>

    <span class="c1"># create reconstructed differential phase field dictionary and store data</span>
    <span class="n">phidpr_dict</span> <span class="o">=</span> <span class="n">get_metadata</span><span class="p">(</span><span class="n">phidp_field</span><span class="p">)</span>
    <span class="n">phidpr_dict</span><span class="p">[</span><span class="s1">&#39;data&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">phidp_rec</span>
    <span class="c1"># phidpr_dict[&#39;valid_min&#39;] = 0.0</span>

    <span class="c1"># create specific phase stdev field dictionary and store data</span>
    <span class="n">kdp_stdev_dict</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="n">kdp_stdev_dict</span><span class="p">[</span><span class="s1">&#39;units&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;degrees/km&#39;</span>
    <span class="n">kdp_stdev_dict</span><span class="p">[</span><span class="s1">&#39;standard_name&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;estimated KDP stdev&#39;</span>
    <span class="n">kdp_stdev_dict</span><span class="p">[</span><span class="s1">&#39;long_name&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;Estimated stdev of spec. diff. phase (KDP)&#39;</span>
    <span class="n">kdp_stdev_dict</span><span class="p">[</span><span class="s1">&#39;coordinates&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;elevation azimuth range&#39;</span>
    <span class="n">kdp_stdev_dict</span><span class="p">[</span><span class="s1">&#39;data&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">kdp_stdev</span>
    <span class="n">kdp_stdev_dict</span><span class="p">[</span><span class="s1">&#39;valid_min&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.0</span>

    <span class="k">if</span> <span class="n">parallel</span><span class="p">:</span>
        <span class="n">pool</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>

    <span class="k">return</span> <span class="n">kdp_dict</span><span class="p">,</span> <span class="n">kdp_stdev_dict</span><span class="p">,</span> <span class="n">phidpr_dict</span></div>


<span class="k">def</span> <span class="nf">_kdp_estimation_backward_fixed</span><span class="p">(</span>
        <span class="n">psidp_in</span><span class="p">,</span> <span class="n">rcov</span><span class="p">,</span> <span class="n">pcov_scale</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">f_transposed</span><span class="p">,</span> <span class="n">h_plus</span><span class="p">,</span>
        <span class="n">c1</span><span class="p">,</span> <span class="n">c2</span><span class="p">,</span> <span class="n">b1</span><span class="p">,</span> <span class="n">b2</span><span class="p">,</span> <span class="n">kdp_th</span><span class="p">,</span> <span class="n">mpsidp</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Processing one profile of Psidp and estimating Kdp and Phidp</span>
<span class="sd">    with the KFE algorithm described in Schneebeli et al, 2014</span>
<span class="sd">    IEEE_TGRS. This routine estimates Kdp in the backward</span>
<span class="sd">    direction given a set of matrices that define the Kalman</span>
<span class="sd">    filter.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    psidp_in : ndarray</span>
<span class="sd">        One-dimensional vector of length -nrg- containining the input psidp</span>
<span class="sd">        [degrees].</span>
<span class="sd">    rcov : 3x3 float array</span>
<span class="sd">        Measurement error covariance matrix.</span>
<span class="sd">    pcov_scale : 4x4 float array</span>
<span class="sd">        Scaled state transition error covariance matrix.</span>
<span class="sd">    f : 4x4 float array</span>
<span class="sd">        Forward state prediction matrix [4x4].</span>
<span class="sd">    f_transposed : 4x4 float array</span>
<span class="sd">        Transpose of F.</span>
<span class="sd">    h_plus : 4x3 float array</span>
<span class="sd">        Measurement prediction matrix [4x3].</span>
<span class="sd">    c1, c2, b1, b2 : floats</span>
<span class="sd">        The values of the intercept of the relation c = b*Kdp - delta.</span>
<span class="sd">        This relation uses b1, c1 IF kdp is lower than a kdp_th and b2, c2</span>
<span class="sd">        otherwise kdp_th.</span>
<span class="sd">    kdp_th : float</span>
<span class="sd">        The kdp threshold which separates the two Kdp - delta regime</span>
<span class="sd">        i.e. the power law relating delta to Kdp will be different if Kdp is</span>
<span class="sd">        larger or smaller than kdp_th.</span>
<span class="sd">    mpsidp : float</span>
<span class="sd">        Final observed value of psidp along the radial (usually also</span>
<span class="sd">        the max value), needed for inverting the psidp vector.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    kdp : ndarray</span>
<span class="sd">        Filtered Kdp [degrees/km]. Same length as Psidp.</span>
<span class="sd">    error_kdp : ndarray</span>
<span class="sd">        Estimated error on Kdp values.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># Define the input</span>
    <span class="n">psidp</span> <span class="o">=</span> <span class="n">psidp_in</span>

    <span class="c1"># invert Psidp (backward estimation)</span>
    <span class="n">psidp</span> <span class="o">=</span> <span class="n">mpsidp</span> <span class="o">-</span> <span class="n">psidp</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">nrg_new</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">psidp</span><span class="p">)</span>

    <span class="c1"># Initialize the state vector to 0</span>
    <span class="n">s</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">([</span><span class="mi">4</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>  <span class="c1"># first state estimate</span>

    <span class="c1"># define measurement vector</span>
    <span class="n">z</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">([</span><span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>

    <span class="c1"># Define the identity matrix</span>
    <span class="n">identity_i</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
    <span class="n">p</span> <span class="o">=</span> <span class="n">identity_i</span> <span class="o">*</span> <span class="mf">4.</span>

    <span class="n">kdp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">([</span><span class="n">nrg_new</span><span class="p">])</span>
    <span class="n">kdp_error</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">([</span><span class="n">nrg_new</span><span class="p">])</span>

    <span class="c1"># Loop on all the gates and apply the filter</span>

    <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">nrg_new</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
        <span class="n">z</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">psidp</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span>
        <span class="n">z</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">psidp</span><span class="p">[</span><span class="n">ii</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>

        <span class="n">s_pred</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">s</span><span class="p">)</span>  <span class="c1"># state prediciton</span>

        <span class="n">p_pred</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">f_transposed</span><span class="p">))</span> <span class="o">+</span> \
            <span class="n">pcov_scale</span>  <span class="c1"># error prediction</span>

        <span class="k">if</span> <span class="n">s_pred</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">kdp_th</span><span class="p">:</span>
            <span class="n">h_plus</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">b2</span>
            <span class="n">z</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">c2</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">h_plus</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">b1</span>
            <span class="n">z</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">c1</span>

        <span class="c1"># as far as i see aludc is symmetrical, so i do not transpose it</span>
        <span class="n">aludc</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">h_plus</span><span class="p">,</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">p_pred</span><span class="p">,</span> <span class="n">h_plus</span><span class="o">.</span><span class="n">T</span><span class="p">)))</span> <span class="o">+</span> <span class="n">rcov</span><span class="p">)</span>

        <span class="c1"># below we get the transposed of B_mat directly</span>
        <span class="n">b_mat</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">h_plus</span><span class="p">,</span> <span class="n">p_pred</span><span class="p">)</span>

        <span class="c1"># Cholesky decomposition</span>
        <span class="n">cho</span> <span class="o">=</span> <span class="n">linalg</span><span class="o">.</span><span class="n">cho_factor</span><span class="p">(</span><span class="n">aludc</span><span class="p">)</span>
        <span class="n">k</span> <span class="o">=</span> <span class="n">linalg</span><span class="o">.</span><span class="n">cho_solve</span><span class="p">(</span><span class="n">cho</span><span class="p">,</span> <span class="n">b_mat</span><span class="p">,</span> <span class="n">check_finite</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                             <span class="n">overwrite_b</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>

        <span class="c1"># Update state and error</span>
        <span class="n">s</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="o">-</span><span class="n">h_plus</span><span class="p">,</span> <span class="n">s_pred</span><span class="p">)</span> <span class="o">+</span> <span class="n">z</span><span class="p">))</span> <span class="o">+</span> <span class="n">s_pred</span>
        <span class="n">p</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">((</span><span class="n">identity_i</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">h_plus</span><span class="p">)),</span> <span class="n">p_pred</span><span class="p">)</span>

        <span class="c1"># Fill the output</span>
        <span class="n">kdp</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span> <span class="o">=</span> <span class="n">s</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">kdp_error</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span> <span class="o">=</span> <span class="n">p</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>

    <span class="c1"># Shift</span>
    <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">kdp</span><span class="p">)</span>
    <span class="n">dummy</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">kdp</span><span class="p">)</span>
    <span class="n">kdp</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">SHIFT</span><span class="p">)</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="n">kdp</span><span class="p">)</span> <span class="o">-</span> <span class="n">SHIFT</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">kdp</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">SHIFT</span><span class="p">)]</span> <span class="o">=</span> <span class="n">dummy</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">SHIFT</span><span class="p">)</span> <span class="o">+</span> <span class="n">SHIFT</span><span class="p">]</span>

    <span class="c1"># Reverse the estimates (backward direction)</span>
    <span class="n">kdp</span> <span class="o">=</span> <span class="n">kdp</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

    <span class="n">kdp_error</span> <span class="o">=</span> <span class="n">kdp_error</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">kdp</span><span class="p">,</span> <span class="n">kdp_error</span>


<span class="k">def</span> <span class="nf">_kdp_estimation_forward_fixed</span><span class="p">(</span>
        <span class="n">psidp_in</span><span class="p">,</span> <span class="n">rcov</span><span class="p">,</span> <span class="n">pcov_scale</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">f_transposed</span><span class="p">,</span> <span class="n">h_plus</span><span class="p">,</span>
        <span class="n">c1</span><span class="p">,</span> <span class="n">c2</span><span class="p">,</span> <span class="n">b1</span><span class="p">,</span> <span class="n">b2</span><span class="p">,</span> <span class="n">kdp_th</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Processing one profile of Psidp and estimating Kdp and Phidp</span>
<span class="sd">    with the KFE algorithm described in Schneebeli et al, 2014</span>
<span class="sd">    IEEE_TGRS. This routine estimates Kdp in the forward</span>
<span class="sd">    direction given a set of matrices that define the Kalman</span>
<span class="sd">    filter.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    psidp_in : ndarray</span>
<span class="sd">        One-dimensional vector of length -nrg- containining the input psidp</span>
<span class="sd">        [degrees].</span>
<span class="sd">    rcov : 3x3 float array.</span>
<span class="sd">        Measurement error covariance matrix.</span>
<span class="sd">    pcov_scale  : 4x4 float array</span>
<span class="sd">        Scaled state transition error covariance matrix.</span>
<span class="sd">    f : 4x4 float array</span>
<span class="sd">        Forward state prediction matrix [4x4].</span>
<span class="sd">    f_transposed : 4x4 float array</span>
<span class="sd">        Transpose of F.</span>
<span class="sd">    h_plus : 4x3 float array*np.nan</span>
<span class="sd">        Measurement prediction matrix [4x3].</span>
<span class="sd">    c1, c2, b1, b2 : floats</span>
<span class="sd">        The values of the intercept of the relation c = b*Kdp - delta.</span>
<span class="sd">        This relation uses b1, c1 IF kdp is lower than a kdp_th and b2, c2</span>
<span class="sd">        otherwise kdp_th.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    kdp : ndarray</span>
<span class="sd">        Filtered Kdp [degrees/km]. Same length as Psidp.</span>
<span class="sd">    phidp : ndarray</span>
<span class="sd">        Estimated phidp (smooth psidp).</span>
<span class="sd">    error_kdp : ndarray</span>
<span class="sd">        Estimated error on Kdp values.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># Define the input</span>
    <span class="n">psidp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">filled</span><span class="p">(</span><span class="n">psidp_in</span><span class="p">)</span>
    <span class="n">nrg_new</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">psidp</span><span class="p">)</span>

    <span class="c1"># Initialize the state vector to 0</span>
    <span class="n">s</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">([</span><span class="mi">4</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>  <span class="c1"># first state estimate</span>

    <span class="c1"># define measurement vector</span>
    <span class="n">z</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">([</span><span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>

    <span class="c1"># Define the identity matrix</span>
    <span class="n">identity_i</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
    <span class="n">p</span> <span class="o">=</span> <span class="n">identity_i</span> <span class="o">*</span> <span class="mf">4.</span>

    <span class="n">phidp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">([</span><span class="n">nrg_new</span><span class="p">])</span>
    <span class="n">kdp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">([</span><span class="n">nrg_new</span><span class="p">])</span>
    <span class="n">kdp_error</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">([</span><span class="n">nrg_new</span><span class="p">])</span>

    <span class="c1"># Loop on all the gates and apply the filter</span>
    <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">nrg_new</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
        <span class="n">z</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">psidp</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span>
        <span class="n">z</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">psidp</span><span class="p">[</span><span class="n">ii</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>

        <span class="n">s_pred</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">s</span><span class="p">)</span>  <span class="c1"># state prediciton</span>

        <span class="n">p_pred</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">f_transposed</span><span class="p">))</span> <span class="o">+</span> \
            <span class="n">pcov_scale</span>  <span class="c1"># error prediction</span>

        <span class="k">if</span> <span class="n">s_pred</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">kdp_th</span><span class="p">:</span>
            <span class="n">h_plus</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">b2</span>
            <span class="n">z</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">c2</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">h_plus</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">b1</span>
            <span class="n">z</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">c1</span>

        <span class="c1"># as far as i see aludc is symmetrical, so i do not transpose it</span>
        <span class="n">aludc</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">h_plus</span><span class="p">,</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">p_pred</span><span class="p">,</span> <span class="n">h_plus</span><span class="o">.</span><span class="n">T</span><span class="p">)))</span> <span class="o">+</span> <span class="n">rcov</span><span class="p">)</span>

        <span class="c1"># below we get the transposed of B_mat directly</span>
        <span class="n">b_mat</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">h_plus</span><span class="p">,</span> <span class="n">p_pred</span><span class="p">)</span>

        <span class="c1"># Cholesky decomposition</span>
        <span class="n">cho</span> <span class="o">=</span> <span class="n">linalg</span><span class="o">.</span><span class="n">cho_factor</span><span class="p">(</span><span class="n">aludc</span><span class="p">)</span>
        <span class="n">k</span> <span class="o">=</span> <span class="n">linalg</span><span class="o">.</span><span class="n">cho_solve</span><span class="p">(</span>
            <span class="n">cho</span><span class="p">,</span>
            <span class="n">b_mat</span><span class="p">,</span>
            <span class="n">check_finite</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
            <span class="n">overwrite_b</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>

        <span class="c1"># Update state and error</span>
        <span class="n">s</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="o">-</span><span class="n">h_plus</span><span class="p">,</span> <span class="n">s_pred</span><span class="p">)</span> <span class="o">+</span> <span class="n">z</span><span class="p">))</span> <span class="o">+</span> <span class="n">s_pred</span>
        <span class="n">p</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">((</span><span class="n">identity_i</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">h_plus</span><span class="p">)),</span> <span class="n">p_pred</span><span class="p">)</span>

        <span class="c1"># Fill the output</span>
        <span class="n">kdp</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span> <span class="o">=</span> <span class="n">s</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">kdp_error</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span> <span class="o">=</span> <span class="n">p</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
        <span class="n">phidp</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span> <span class="o">=</span> <span class="n">s</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>

    <span class="c1"># Shift</span>
    <span class="n">dummy</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">kdp</span><span class="p">)</span>
    <span class="n">kdp</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">SHIFT</span><span class="p">)</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="n">kdp</span><span class="p">)</span> <span class="o">-</span> <span class="n">SHIFT</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">kdp</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">kdp</span><span class="p">)</span> <span class="o">-</span> <span class="n">SHIFT</span><span class="p">)</span>
        <span class="p">]</span> <span class="o">=</span> <span class="n">dummy</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">kdp</span><span class="p">)</span> <span class="o">-</span> <span class="n">SHIFT</span><span class="p">)</span> <span class="o">+</span> <span class="n">SHIFT</span><span class="p">]</span>

    <span class="k">return</span> <span class="n">kdp</span><span class="p">,</span> <span class="n">phidp</span><span class="p">,</span> <span class="n">kdp_error</span>


<span class="k">def</span> <span class="nf">_kdp_kalman_profile</span><span class="p">(</span><span class="n">psidp_in</span><span class="p">,</span> <span class="n">dr</span><span class="p">,</span> <span class="n">band</span><span class="o">=</span><span class="s1">&#39;X&#39;</span><span class="p">,</span> <span class="n">rcov</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">pcov</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Estimates Kdp with the Kalman filter method by Schneebeli and al. (2014)</span>
<span class="sd">    for a set of psidp measurements.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    psidp_in : ndarray</span>
<span class="sd">        One-dimensional vector of length -nrg- containining the input psidp</span>
<span class="sd">        [degrees].</span>
<span class="sd">    dr : float</span>
<span class="sd">        Range resolution in meters.</span>
<span class="sd">    band : char, optional</span>
<span class="sd">       Radar frequency band string. Accepted &quot;X&quot;, &quot;C&quot;, &quot;S&quot; (capital</span>
<span class="sd">       or not). The band is used to compute intercepts -c and slope b of the</span>
<span class="sd">       delta = b*Kdp+c relation.</span>
<span class="sd">    rcov : 3x3 float array, optional</span>
<span class="sd">        Measurement error covariance matrix.</span>
<span class="sd">    pcov  : 4x4 float array, optional</span>
<span class="sd">        Scaled state transition error covariance matrix.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    kdp_dict : ndarray</span>
<span class="sd">        Retrieved specific differential phase data.</span>
<span class="sd">    kdp_std_dict : ndarray</span>
<span class="sd">        Estimated specific differential phase standard dev. data.</span>
<span class="sd">    phidpr_dict : ndarray</span>
<span class="sd">        Retrieved differential phase data.</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    Schneebeli, M., Grazioli, J., and Berne, A.: Improved Estimation</span>
<span class="sd">    of the Specific Differential Phase Shift Using a Compilation of</span>
<span class="sd">    Kalman Filter Ensembles, IEEE T. Geosci. Remote Sens., 52,</span>
<span class="sd">    5137-5149, doi:10.1109/TGRS.2013.2287017, 2014.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">dr</span> <span class="o">=</span> <span class="n">dr</span> <span class="o">/</span> <span class="mf">1000.</span>  <span class="c1"># Convert rad. res. to km</span>

    <span class="c1"># NOTE! Parameters are not checked to save as much time as possible</span>

    <span class="c1"># Replace missing values with nans</span>
    <span class="n">psidp_in</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">filled</span><span class="p">(</span><span class="n">psidp_in</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>
    <span class="c1"># Check if psidp has at least one finite value</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">psidp_in</span><span class="p">)</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
        <span class="k">return</span> <span class="n">psidp_in</span><span class="p">,</span> <span class="n">psidp_in</span><span class="p">,</span> <span class="n">psidp_in</span>  <span class="c1"># Return the NaNs...</span>

    <span class="c1"># Set default of the error covariance matrices</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">pcov</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
        <span class="n">pcov</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[(</span><span class="mf">0.11</span> <span class="o">+</span> <span class="mf">1.56</span> <span class="o">*</span> <span class="n">dr</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span>
                          <span class="p">(</span><span class="mf">0.11</span> <span class="o">+</span> <span class="mf">1.85</span> <span class="o">*</span> <span class="n">dr</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span>
                          <span class="mi">0</span><span class="p">,</span>
                          <span class="p">(</span><span class="mf">0.01</span> <span class="o">+</span> <span class="mf">1.1</span> <span class="o">*</span> <span class="n">dr</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">],</span>
                         <span class="p">[(</span><span class="mf">0.11</span> <span class="o">+</span> <span class="mf">1.85</span> <span class="o">*</span> <span class="n">dr</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span>
                          <span class="p">(</span><span class="mf">0.18</span> <span class="o">+</span> <span class="mf">3.03</span> <span class="o">*</span> <span class="n">dr</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span>
                          <span class="mi">0</span><span class="p">,</span>
                          <span class="p">(</span><span class="mf">0.01</span> <span class="o">+</span> <span class="mf">1.23</span> <span class="o">*</span> <span class="n">dr</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">],</span>
                         <span class="p">[</span><span class="mi">0</span><span class="p">,</span>
                          <span class="mi">0</span><span class="p">,</span>
                          <span class="mi">0</span><span class="p">,</span>
                          <span class="mi">0</span><span class="p">],</span>
                         <span class="p">[(</span><span class="mf">0.01</span> <span class="o">+</span> <span class="mf">1.1</span> <span class="o">*</span> <span class="n">dr</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span>
                          <span class="p">(</span><span class="mf">0.01</span> <span class="o">+</span> <span class="mf">1.23</span> <span class="o">*</span> <span class="n">dr</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span>
                          <span class="mi">0</span><span class="p">,</span>
                          <span class="p">(</span><span class="o">-</span><span class="mf">0.04</span> <span class="o">+</span> <span class="mf">1.27</span> <span class="o">*</span> <span class="n">dr</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">]])</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">rcov</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
        <span class="n">rcov</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mf">4.10625</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.0498779</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.0634192</span><span class="p">],</span>
                         <span class="p">[</span><span class="o">-</span><span class="mf">0.0498779</span><span class="p">,</span> <span class="mf">4.02369</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.0421455</span><span class="p">],</span>
                         <span class="p">[</span><span class="o">-</span><span class="mf">0.0634192</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.0421455</span><span class="p">,</span> <span class="mf">1.44300</span><span class="p">]])</span>

    <span class="c1"># Define default parameters</span>
    <span class="c1"># Intercepts -c and slope b of delta=b*Kdp+c</span>
    <span class="c1"># According to the Kdp threshold selected</span>

    <span class="k">if</span> <span class="n">band</span> <span class="o">==</span> <span class="s1">&#39;X&#39;</span><span class="p">:</span>
        <span class="n">c1</span> <span class="o">=</span> <span class="o">-</span><span class="mf">0.054</span>
        <span class="n">c2</span> <span class="o">=</span> <span class="o">-</span><span class="mf">6.155</span>
        <span class="n">b1</span> <span class="o">=</span> <span class="mf">2.3688</span>
        <span class="n">b2</span> <span class="o">=</span> <span class="mf">0.2734</span>
        <span class="n">kdp_th</span> <span class="o">=</span> <span class="mf">2.5</span>
    <span class="k">elif</span> <span class="n">band</span> <span class="o">==</span> <span class="s1">&#39;C&#39;</span><span class="p">:</span>
        <span class="n">c1</span> <span class="o">=</span> <span class="o">-</span><span class="mf">0.036</span>
        <span class="n">c2</span> <span class="o">=</span> <span class="o">-</span><span class="mf">1.03</span>
        <span class="n">b1</span> <span class="o">=</span> <span class="mf">0.53</span>
        <span class="n">b2</span> <span class="o">=</span> <span class="mf">0.15</span>
        <span class="n">kdp_th</span> <span class="o">=</span> <span class="mf">2.5</span>
    <span class="k">elif</span> <span class="n">band</span> <span class="o">==</span> <span class="s1">&#39;S&#39;</span><span class="p">:</span>
        <span class="n">c1</span> <span class="o">=</span> <span class="o">-</span><span class="mf">0.024</span>
        <span class="n">c2</span> <span class="o">=</span> <span class="o">-</span><span class="mf">0.15</span>
        <span class="n">b1</span> <span class="o">=</span> <span class="mf">0.19</span>
        <span class="n">b2</span> <span class="o">=</span> <span class="mf">0.019</span>
        <span class="n">kdp_th</span> <span class="o">=</span> <span class="mf">1.1</span>

    <span class="c1"># Parameters for the final selection from the KF ensemble members</span>
    <span class="n">fac1</span> <span class="o">=</span> <span class="mf">1.2</span>
    <span class="n">fac2</span> <span class="o">=</span> <span class="mf">3.</span>

    <span class="n">th1_comp</span> <span class="o">=</span> <span class="o">-</span><span class="mf">0.15</span>
    <span class="n">th2_comp</span> <span class="o">=</span> <span class="mf">0.15</span>
    <span class="n">th1_final</span> <span class="o">=</span> <span class="o">-</span><span class="mf">0.25</span>

    <span class="c1"># Kalman matrices</span>
    <span class="c1"># State matrix</span>
    <span class="n">f</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span>
                  <span class="p">[</span><span class="mi">2</span> <span class="o">*</span> <span class="n">dr</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
    <span class="n">f_transposed</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">T</span>

    <span class="c1"># Measurement prediction matrix--------------------------------</span>
    <span class="c1"># J. Grazioli modification 07.2015 --previous H_plus buggy--</span>
    <span class="n">h_plus</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
        <span class="p">[[</span><span class="o">-</span><span class="mi">2</span> <span class="o">*</span> <span class="n">dr</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span> <span class="o">*</span> <span class="n">dr</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>

    <span class="c1"># Define the input</span>
    <span class="n">psidp</span> <span class="o">=</span> <span class="n">psidp_in</span>
    <span class="c1"># Get indices of finite data</span>
    <span class="n">real_data_ind</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">psidp</span><span class="o">.</span><span class="n">ravel</span><span class="p">()))[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">offset</span> <span class="o">=</span> <span class="n">real_data_ind</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">real_data_ind</span><span class="p">):</span>
        <span class="n">mpsidp</span> <span class="o">=</span> <span class="n">psidp</span><span class="o">.</span><span class="n">ravel</span><span class="p">()[</span><span class="n">real_data_ind</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">mpsidp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>

    <span class="n">psidp</span> <span class="o">=</span> <span class="n">psidp</span><span class="p">[</span><span class="n">offset</span><span class="p">:</span><span class="n">real_data_ind</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>

    <span class="n">nrg</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">psidp</span><span class="p">)</span>

    <span class="c1"># Define the output</span>
    <span class="n">kdp_filter_out</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">([</span><span class="n">nrg</span><span class="p">,</span> <span class="p">])</span>

    <span class="n">kdp_mat</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">([</span><span class="n">nrg</span><span class="p">,</span> <span class="mi">2</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">SCALERS</span><span class="p">)])</span>
    <span class="n">kdp_sim</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">([</span><span class="n">nrg</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">SCALERS</span><span class="p">)])</span>
    <span class="n">phidp_filter_out</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">([</span><span class="n">nrg</span><span class="p">])</span>

    <span class="c1"># Prepare a longer array with some extra gates on each side</span>
    <span class="c1"># add values at the beginning and at the end of the profile</span>
    <span class="n">psidp_long</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">([</span><span class="n">nrg</span> <span class="o">+</span> <span class="n">PADDING</span> <span class="o">*</span> <span class="mi">2</span><span class="p">,</span> <span class="p">])</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>

    <span class="n">nn</span> <span class="o">=</span> <span class="n">nrg</span> <span class="o">+</span> <span class="n">PADDING</span> <span class="o">*</span> <span class="mi">2</span>

    <span class="n">noise</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="n">PADDING</span><span class="p">)</span>
    <span class="n">psidp_long</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="n">PADDING</span><span class="p">]</span> <span class="o">=</span> <span class="n">noise</span> <span class="o">+</span> <span class="n">psidp</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">psidp_long</span><span class="p">[</span><span class="n">nrg</span> <span class="o">+</span> <span class="n">PADDING</span><span class="p">:</span> <span class="n">nrg</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">PADDING</span><span class="p">]</span> <span class="o">=</span> <span class="n">mpsidp</span> <span class="o">+</span> <span class="n">noise</span>
    <span class="n">psidp_long</span><span class="p">[</span><span class="n">PADDING</span><span class="p">:</span><span class="n">nrg</span> <span class="o">+</span> <span class="n">PADDING</span><span class="p">]</span> <span class="o">=</span> <span class="n">psidp</span>

    <span class="n">psidp</span> <span class="o">=</span> <span class="n">psidp_long</span>

    <span class="c1"># Get information of valid and non valid points in psidp the new psidp</span>
    <span class="n">nonan</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">psidp</span><span class="p">))[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">nan</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">psidp</span><span class="p">))[</span><span class="mi">0</span><span class="p">]</span>

    <span class="n">ranged</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">nn</span><span class="p">)</span>

    <span class="n">psidp_interp</span> <span class="o">=</span> <span class="n">psidp</span>

    <span class="c1"># interpolate</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">nan</span><span class="p">):</span>
        <span class="n">interp</span> <span class="o">=</span> <span class="n">interpolate</span><span class="o">.</span><span class="n">interp1d</span><span class="p">(</span><span class="n">ranged</span><span class="p">[</span><span class="n">nonan</span><span class="p">],</span> <span class="n">psidp</span><span class="p">[</span><span class="n">nonan</span><span class="p">],</span> <span class="n">kind</span><span class="o">=</span><span class="s1">&#39;zero&#39;</span><span class="p">)</span>
        <span class="n">psidp_interp</span><span class="p">[</span><span class="n">nan</span><span class="p">]</span> <span class="o">=</span> <span class="n">interp</span><span class="p">(</span><span class="n">ranged</span><span class="p">[</span><span class="n">nan</span><span class="p">])</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">psidp_interp</span> <span class="o">=</span> <span class="n">psidp</span>

    <span class="c1"># add noise</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">nan</span><span class="p">):</span>
        <span class="n">psidp_interp</span><span class="p">[</span><span class="n">nan</span><span class="p">]</span> <span class="o">=</span> <span class="n">psidp_interp</span><span class="p">[</span><span class="n">nan</span><span class="p">]</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">nan</span><span class="p">))</span>

    <span class="c1"># Define the final input and output</span>
    <span class="n">psidp</span> <span class="o">=</span> <span class="n">psidp_interp</span>


    <span class="c1"># Smallest scaler</span>
    <span class="n">scaler</span> <span class="o">=</span> <span class="mi">10</span> <span class="o">**</span> <span class="p">(</span><span class="o">-</span><span class="mf">2.</span><span class="p">)</span>

    <span class="c1"># Backward</span>
    <span class="n">kdp_dummy_b2</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">_kdp_estimation_backward_fixed</span><span class="p">(</span><span class="n">psidp</span><span class="p">,</span> <span class="n">rcov</span><span class="p">,</span>
                                                     <span class="n">pcov</span> <span class="o">*</span> <span class="n">scaler</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span>
                                                     <span class="n">f_transposed</span><span class="p">,</span> <span class="n">h_plus</span><span class="p">,</span>
                                                     <span class="n">c1</span><span class="p">,</span> <span class="n">c2</span><span class="p">,</span> <span class="n">b1</span><span class="p">,</span> <span class="n">b2</span><span class="p">,</span>
                                                     <span class="n">kdp_th</span><span class="p">,</span> <span class="n">mpsidp</span><span class="p">)</span>
    <span class="n">kdp002</span> <span class="o">=</span> <span class="n">kdp_dummy_b2</span><span class="p">[</span><span class="n">PADDING</span><span class="p">:</span><span class="n">nrg</span> <span class="o">+</span> <span class="n">PADDING</span><span class="p">]</span>

    <span class="c1"># Forward</span>
    <span class="n">kdp_dummy_b2</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">_kdp_estimation_forward_fixed</span><span class="p">(</span><span class="n">psidp</span><span class="p">,</span> <span class="n">rcov</span><span class="p">,</span>
                                                       <span class="n">pcov</span> <span class="o">*</span> <span class="n">scaler</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span>
                                                       <span class="n">f_transposed</span><span class="p">,</span> <span class="n">h_plus</span><span class="p">,</span>
                                                       <span class="n">c1</span><span class="p">,</span> <span class="n">c2</span><span class="p">,</span> <span class="n">b1</span><span class="p">,</span> <span class="n">b2</span><span class="p">,</span> <span class="n">kdp_th</span><span class="p">)</span>
    <span class="n">kdp002f</span> <span class="o">=</span> <span class="n">kdp_dummy_b2</span><span class="p">[</span><span class="n">PADDING</span><span class="p">:</span><span class="n">nrg</span> <span class="o">+</span> <span class="n">PADDING</span><span class="p">]</span>

    <span class="c1"># Generate the ensemble of Kalman filters estimates in backward and</span>
    <span class="c1"># Forward directions</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">sc</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">SCALERS</span><span class="p">):</span>  <span class="c1"># Loop on scalers</span>
        <span class="c1"># Forward</span>
        <span class="n">kdp_dummy_f2</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">_kdp_estimation_forward_fixed</span><span class="p">(</span><span class="n">psidp</span><span class="p">,</span>
                                                           <span class="n">rcov</span><span class="p">,</span> <span class="n">pcov</span> <span class="o">*</span> <span class="n">sc</span><span class="p">,</span>
                                                           <span class="n">f</span><span class="p">,</span> <span class="n">f_transposed</span><span class="p">,</span>
                                                           <span class="n">h_plus</span><span class="p">,</span> <span class="n">c1</span><span class="p">,</span> <span class="n">c2</span><span class="p">,</span>
                                                           <span class="n">b1</span><span class="p">,</span> <span class="n">b2</span><span class="p">,</span> <span class="n">kdp_th</span><span class="p">)</span>
        <span class="n">kdp_mat</span><span class="p">[:,</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">kdp_dummy_f2</span><span class="p">[</span><span class="n">PADDING</span><span class="p">:</span><span class="n">nrg</span> <span class="o">+</span> <span class="n">PADDING</span><span class="p">]</span>

        <span class="c1"># Backward</span>
        <span class="n">kdp_dummy_b2</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">_kdp_estimation_backward_fixed</span><span class="p">(</span><span class="n">psidp</span><span class="p">,</span> <span class="n">rcov</span><span class="p">,</span>
                                                         <span class="n">pcov</span> <span class="o">*</span> <span class="n">sc</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span>
                                                         <span class="n">f_transposed</span><span class="p">,</span> <span class="n">h_plus</span><span class="p">,</span>
                                                         <span class="n">c1</span><span class="p">,</span> <span class="n">c2</span><span class="p">,</span> <span class="n">b1</span><span class="p">,</span> <span class="n">b2</span><span class="p">,</span>
                                                         <span class="n">kdp_th</span><span class="p">,</span> <span class="n">mpsidp</span><span class="p">)</span>
        <span class="n">kdp_mat</span><span class="p">[:,</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">kdp_dummy_b2</span><span class="p">[</span><span class="n">PADDING</span><span class="p">:</span><span class="n">nrg</span> <span class="o">+</span> <span class="n">PADDING</span><span class="p">]</span>

    <span class="c1"># Compile the final estimate</span>
    <span class="c1"># Get some reference mean values</span>
    <span class="n">kdp_mean</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nanmean</span><span class="p">(</span><span class="n">kdp_mat</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">kdp_mean_shift</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">roll</span><span class="p">(</span><span class="n">kdp_mean</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">diff_mean</span> <span class="o">=</span> <span class="n">kdp_mean</span> <span class="o">-</span> <span class="n">kdp_mean_shift</span>

    <span class="n">kdp_std</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nanstd</span><span class="p">(</span><span class="n">kdp_mat</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">diff_mean</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">4</span><span class="p">:</span>
        <span class="n">size_filt</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">diff_mean</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">size_filt</span> <span class="o">=</span> <span class="mi">4</span>

    <span class="n">diff_mean_smooth</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">convolve</span><span class="p">(</span><span class="n">diff_mean</span><span class="p">,</span>
                                   <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="n">size_filt</span><span class="p">,))</span> <span class="o">/</span> <span class="n">size_filt</span><span class="p">,</span>
                                   <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;same&#39;</span><span class="p">)</span>

    <span class="c1"># Backward estimate if diff_mean greater than a defined threshold</span>
    <span class="n">condi</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">diff_mean_smooth</span> <span class="o">&gt;</span> <span class="n">th2_comp</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">condi</span><span class="p">):</span>
        <span class="n">kdp_dummy</span> <span class="o">=</span> <span class="n">kdp_mat</span><span class="p">[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">SCALERS</span><span class="p">))</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>
        <span class="n">kdp_sim</span><span class="p">[</span><span class="n">condi</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">kdp_dummy</span><span class="p">[</span><span class="n">condi</span><span class="p">,</span> <span class="p">:]</span>

    <span class="c1"># Forward estimate if diff_mean lower than a defined threshold</span>
    <span class="n">condi</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">diff_mean_smooth</span> <span class="o">&lt;</span> <span class="n">th1_comp</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">condi</span><span class="p">):</span>
        <span class="n">kdp_dummy</span> <span class="o">=</span> <span class="n">kdp_mat</span><span class="p">[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">SCALERS</span><span class="p">))</span> <span class="o">*</span> <span class="mi">2</span><span class="p">]</span>
        <span class="n">kdp_sim</span><span class="p">[</span><span class="n">condi</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">kdp_dummy</span><span class="p">[</span><span class="n">condi</span><span class="p">,</span> <span class="p">:]</span>

    <span class="c1"># Combination of the two in the middle</span>
    <span class="n">condi</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span><span class="n">diff_mean_smooth</span> <span class="o">&gt;=</span> <span class="n">th1_comp</span><span class="p">,</span>
                                    <span class="n">diff_mean_smooth</span> <span class="o">&lt;=</span> <span class="n">th2_comp</span><span class="p">))[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">condi</span><span class="p">):</span>
        <span class="n">weight2</span> <span class="o">=</span> <span class="p">(</span><span class="o">-</span><span class="mf">0.5</span> <span class="o">/</span> <span class="mf">0.15</span><span class="p">)</span> <span class="o">*</span> <span class="n">diff_mean_smooth</span> <span class="o">+</span> <span class="mf">0.5</span>

        <span class="n">weight2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span><span class="n">weight2</span><span class="p">,</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">SCALERS</span><span class="p">),</span> <span class="mi">1</span><span class="p">))</span><span class="o">.</span><span class="n">T</span>

        <span class="n">kdp_dummy</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">weight2</span><span class="p">)</span><span class="o">*</span><span class="n">kdp_mat</span><span class="p">[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">SCALERS</span><span class="p">))</span><span class="o">*</span><span class="mi">2</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> \
            <span class="o">+</span> <span class="n">weight2</span> <span class="o">*</span> <span class="n">kdp_mat</span><span class="p">[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">SCALERS</span><span class="p">))</span> <span class="o">*</span> <span class="mi">2</span><span class="p">]</span>
        <span class="n">kdp_sim</span><span class="p">[</span><span class="n">condi</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">kdp_dummy</span><span class="p">[</span><span class="n">condi</span><span class="p">,</span> <span class="p">:]</span>

    <span class="c1"># Now we reduced to 11 ensemble members: compile the final one</span>
    <span class="n">kdp_mean_sim</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nanmean</span><span class="p">(</span><span class="n">kdp_sim</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">kdp_std_sim</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nanstd</span><span class="p">(</span><span class="n">kdp_sim</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">kdp_low_mean2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nanmean</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="n">kdp002</span><span class="p">,</span> <span class="n">kdp002f</span><span class="p">))</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

    <span class="c1"># Get the range of ensemble members that compile</span>
    <span class="c1"># a final estimate</span>

    <span class="c1"># Lower bounds</span>
    <span class="n">lower_bound</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">kdp_mean_sim</span> <span class="o">*</span> <span class="n">fac1</span><span class="p">)</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">kdp_std_sim</span> <span class="o">*</span> <span class="n">fac2</span><span class="p">)</span>
    <span class="n">lower_bound</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="n">lower_bound</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
    <span class="n">lower_bound</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">minimum</span><span class="p">(</span><span class="n">lower_bound</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">SCALERS</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>

    <span class="c1"># Upper bounds</span>
    <span class="n">upper_bound</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">kdp_mean_sim</span> <span class="o">*</span> <span class="n">fac1</span><span class="p">)</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">kdp_std_sim</span> <span class="o">*</span> <span class="n">fac2</span><span class="p">)</span>
    <span class="n">upper_bound</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="n">upper_bound</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
    <span class="n">upper_bound</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">minimum</span><span class="p">(</span><span class="n">upper_bound</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">SCALERS</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>

    <span class="c1"># Final selection of the ensemble members</span>
    <span class="k">for</span> <span class="n">uu</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">nrg</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
        <span class="n">selection_vector</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span>
            <span class="n">upper_bound</span><span class="p">[</span><span class="n">uu</span><span class="p">]</span> <span class="o">-</span> <span class="n">lower_bound</span><span class="p">[</span><span class="n">uu</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="n">lower_bound</span><span class="p">[</span><span class="n">uu</span><span class="p">]</span>
        <span class="n">selection_vector</span> <span class="o">=</span> <span class="n">selection_vector</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
        <span class="n">kdp_filter_out</span><span class="p">[</span><span class="n">uu</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">kdp_sim</span><span class="p">[</span><span class="n">uu</span><span class="p">,</span> <span class="n">selection_vector</span><span class="p">])</span>

    <span class="c1"># Final filtering of excessively negative values:</span>
    <span class="c1"># TO DO: It would be better to get rid of this filtering</span>
    <span class="n">ind_lt_0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">kdp_filter_out</span> <span class="o">&lt;</span> <span class="n">th1_final</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>

    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">ind_lt_0</span><span class="p">):</span>
        <span class="n">kdp_filter_out</span><span class="p">[</span><span class="n">ind_lt_0</span><span class="p">]</span> <span class="o">=</span> <span class="n">kdp_low_mean2</span><span class="p">[</span><span class="n">ind_lt_0</span><span class="p">]</span>

    <span class="c1"># Compute phidp from Kdp</span>
    <span class="n">phidp_filter_out</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cumsum</span><span class="p">(</span><span class="n">kdp_filter_out</span><span class="p">)</span> <span class="o">*</span> <span class="mf">2.</span> <span class="o">*</span> <span class="n">dr</span>

    <span class="n">phinan</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">psidp</span><span class="p">))[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">phinan</span><span class="p">):</span>
        <span class="n">phidp_filter_out</span><span class="p">[</span><span class="n">phinan</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
        <span class="n">kdp_filter_out</span><span class="p">[</span><span class="n">phinan</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
    <span class="n">phidp_filter_out</span><span class="p">[</span><span class="n">nrg</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
    <span class="n">kdp_filter_out</span><span class="p">[</span><span class="n">nrg</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>

    <span class="c1"># Pad with nan if offset &gt; 0</span>
    <span class="n">kdp_filter_out</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">pad</span><span class="p">(</span><span class="n">kdp_filter_out</span><span class="p">,</span> <span class="p">(</span><span class="n">offset</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;constant&#39;</span><span class="p">,</span>
                            <span class="n">constant_values</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>
    <span class="n">kdp_std</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">pad</span><span class="p">(</span><span class="n">kdp_std</span><span class="p">,</span> <span class="p">(</span><span class="n">offset</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;constant&#39;</span><span class="p">,</span>
                     <span class="n">constant_values</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>
    <span class="n">phidp_filter_out</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">pad</span><span class="p">(</span><span class="n">phidp_filter_out</span><span class="p">,</span> <span class="p">(</span><span class="n">offset</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;constant&#39;</span><span class="p">,</span>
                              <span class="n">constant_values</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">kdp_filter_out</span><span class="p">,</span> <span class="n">kdp_std</span><span class="p">,</span> <span class="n">phidp_filter_out</span>


<div class="viewcode-block" id="kdp_vulpiani"><a class="viewcode-back" href="../../../API/generated/pyart.retrieve.kdp_vulpiani.html#pyart.retrieve.kdp_vulpiani">[docs]</a><span class="k">def</span> <span class="nf">kdp_vulpiani</span><span class="p">(</span><span class="n">radar</span><span class="p">,</span> <span class="n">gatefilter</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">fill_value</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">psidp_field</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">kdp_field</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">phidp_field</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">band</span><span class="o">=</span><span class="s1">&#39;C&#39;</span><span class="p">,</span> <span class="n">windsize</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span>
                 <span class="n">n_iter</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">interp</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">prefilter_psidp</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                 <span class="n">filter_opt</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">parallel</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Estimates Kdp with the Vulpiani method for a 2D array of psidp measurements</span>
<span class="sd">    with the first dimension being the distance from radar and the second</span>
<span class="sd">    dimension being the angles (azimuths for PPI, elev for RHI).The input psidp</span>
<span class="sd">    is assumed to be pre-filtered (for ex. with the filter_psidp function)</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    radar : Radar</span>
<span class="sd">        Radar containing differential phase field.</span>
<span class="sd">    gatefilter : GateFilter, optional</span>
<span class="sd">        A GateFilter indicating radar gates that should be excluded when</span>
<span class="sd">        analysing differential phase measurements.</span>
<span class="sd">    fill_value : float, optional</span>
<span class="sd">        Value indicating missing or bad data in differential phase field, if</span>
<span class="sd">        not specified, the default in the Py-ART configuration file will be</span>
<span class="sd">        used</span>
<span class="sd">    psidp_field : str, optional</span>
<span class="sd">        Total differential phase field. If None, the default field name must be</span>
<span class="sd">        specified in the Py-ART configuration file.</span>
<span class="sd">    kdp_field : str, optional</span>
<span class="sd">        Specific differential phase field. If None, the default field name must</span>
<span class="sd">        be specified in the Py-ART configuration file.</span>
<span class="sd">    phidp_field : str, optional</span>
<span class="sd">        Propagation differential phase field. If None, the default field name</span>
<span class="sd">        must be specified in the Py-ART configuration file.</span>
<span class="sd">    band : char, optional</span>
<span class="sd">        Radar frequency band string. Accepted &quot;X&quot;, &quot;C&quot;, &quot;S&quot; (capital</span>
<span class="sd">        or not). It is used to set default boundaries for expected</span>
<span class="sd">        values of Kdp.</span>
<span class="sd">    windsize : int, optional</span>
<span class="sd">        Size in # of gates of the range derivative window. Should be even.</span>
<span class="sd">    n_iter : int, optional</span>
<span class="sd">        Number of iterations of the method. Default is 10.</span>
<span class="sd">    interp : bool, optional</span>
<span class="sd">        If True, all the nans are interpolated.The advantage is that less data</span>
<span class="sd">        are lost (the iterations in fact are &quot;eating the edges&quot;) but some</span>
<span class="sd">        non-linear errors may be introduced.</span>
<span class="sd">    prefilter_psidp : bool, optional</span>
<span class="sd">        If set, the psidp measurements will first be filtered with the</span>
<span class="sd">        filter_psidp method, which can improve the quality of the final Kdp.</span>
<span class="sd">    filter_opt : dict, optional</span>
<span class="sd">        The arguments for the prefilter_psidp method, if empty, the defaults</span>
<span class="sd">        arguments of this method will be used.</span>
<span class="sd">    parallel : bool, optional</span>
<span class="sd">        Flag to enable parallel computation (one core for every psidp profile).</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    kdp_dict : dict</span>
<span class="sd">        Retrieved specific differential phase data and metadata.</span>
<span class="sd">    phidpr_dict,: dict</span>
<span class="sd">        Retrieved differential phase data and metadata.</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    Gianfranco Vulpiani, Mario Montopoli, Luca Delli Passeri, Antonio G. Gioia,</span>
<span class="sd">    Pietro Giordano, and Frank S. Marzano, 2012: On the Use of Dual-Polarized</span>
<span class="sd">    C-Band Radar for Operational Rainfall Retrieval in Mountainous Areas.</span>
<span class="sd">    J. Appl. Meteor. Climatol., 51, 405-425, doi: 10.1175/JAMC-D-10-05024.1.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">mod</span><span class="p">(</span><span class="n">windsize</span><span class="p">,</span> <span class="mi">2</span><span class="p">):</span>
        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s1">&#39;In the Vulpiani method, the windsize should be even. &#39;</span>
                      <span class="o">+</span> <span class="s1">&#39;Using default value, windsize = 10&#39;</span><span class="p">)</span>
        <span class="n">windsize</span> <span class="o">=</span> <span class="mi">10</span>

    <span class="k">if</span> <span class="n">parallel</span><span class="p">:</span>
        <span class="kn">import</span> <span class="nn">multiprocessing</span> <span class="k">as</span> <span class="nn">mp</span>
        <span class="n">pool</span> <span class="o">=</span> <span class="n">mp</span><span class="o">.</span><span class="n">Pool</span><span class="p">(</span><span class="n">processes</span><span class="o">=</span><span class="n">mp</span><span class="o">.</span><span class="n">cpu_count</span><span class="p">(),</span> <span class="n">maxtasksperchild</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

    <span class="c1"># parse fill value</span>
    <span class="k">if</span> <span class="n">fill_value</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">fill_value</span> <span class="o">=</span> <span class="n">get_fillvalue</span><span class="p">()</span>

    <span class="c1"># parse field names</span>
    <span class="k">if</span> <span class="n">psidp_field</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">psidp_field</span> <span class="o">=</span> <span class="n">get_field_name</span><span class="p">(</span><span class="s1">&#39;differential_phase&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">kdp_field</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">kdp_field</span> <span class="o">=</span> <span class="n">get_field_name</span><span class="p">(</span><span class="s1">&#39;specific_differential_phase&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">phidp_field</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">phidp_field</span> <span class="o">=</span> <span class="n">get_field_name</span><span class="p">(</span><span class="s1">&#39;differential_phase&#39;</span><span class="p">)</span>

    <span class="c1"># parse range resolution, length scale and low-pass filter constraint</span>
    <span class="c1"># weight</span>
    <span class="n">dr</span> <span class="o">=</span> <span class="n">_parse_range_resolution</span><span class="p">(</span><span class="n">radar</span><span class="p">,</span> <span class="n">check_uniform</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="c1"># parse total differential phase measurements</span>
    <span class="k">if</span> <span class="n">prefilter_psidp</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">filter_opt</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">filter_opt</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="c1"># Assign psidp field to filter_psidp inputs</span>
        <span class="n">filter_opt</span><span class="p">[</span><span class="s1">&#39;psidp_field&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">psidp_field</span>
        <span class="c1"># Filter psidp</span>
        <span class="n">psidp_o</span> <span class="o">=</span> <span class="n">filter_psidp</span><span class="p">(</span><span class="n">radar</span><span class="p">,</span> <span class="o">**</span><span class="n">filter_opt</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">psidp_o</span> <span class="o">=</span> <span class="n">radar</span><span class="o">.</span><span class="n">fields</span><span class="p">[</span><span class="n">psidp_field</span><span class="p">][</span><span class="s1">&#39;data&#39;</span><span class="p">]</span>

    <span class="c1"># mask radar gates indicated by the gate filter</span>
    <span class="k">if</span> <span class="n">gatefilter</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">psidp_o</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">masked_where</span><span class="p">(</span><span class="n">gatefilter</span><span class="o">.</span><span class="n">gate_excluded</span><span class="p">,</span> <span class="n">psidp_o</span><span class="p">)</span>

    <span class="n">func</span> <span class="o">=</span> <span class="n">partial</span><span class="p">(</span><span class="n">_kdp_vulpiani_profile</span><span class="p">,</span> <span class="n">dr</span><span class="o">=</span><span class="n">dr</span><span class="p">,</span> <span class="n">windsize</span><span class="o">=</span><span class="n">windsize</span><span class="p">,</span>
                   <span class="n">band</span><span class="o">=</span><span class="n">band</span><span class="p">,</span> <span class="n">n_iter</span><span class="o">=</span><span class="n">n_iter</span><span class="p">,</span> <span class="n">interp</span><span class="o">=</span><span class="n">interp</span><span class="p">)</span>

    <span class="n">all_psidp_prof</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">psidp_o</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">parallel</span><span class="p">:</span>
        <span class="n">list_est</span> <span class="o">=</span> <span class="n">pool</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="n">all_psidp_prof</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">list_est</span> <span class="o">=</span> <span class="nb">map</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="n">all_psidp_prof</span><span class="p">)</span>

    <span class="n">kdp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">psidp_o</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
    <span class="n">kdp</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">masked</span>
    <span class="n">kdp</span><span class="o">.</span><span class="n">set_fill_value</span><span class="p">(</span><span class="n">fill_value</span><span class="p">)</span>

    <span class="n">phidp_rec</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">psidp_o</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
    <span class="n">phidp_rec</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">masked</span>
    <span class="n">phidp_rec</span><span class="o">.</span><span class="n">set_fill_value</span><span class="p">(</span><span class="n">fill_value</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">l</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">list_est</span><span class="p">):</span>
        <span class="n">kdp</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="mi">0</span><span class="p">:</span><span class="nb">len</span><span class="p">(</span><span class="n">l</span><span class="p">[</span><span class="mi">0</span><span class="p">])]</span> <span class="o">=</span> <span class="n">l</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">phidp_rec</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="mi">0</span><span class="p">:</span><span class="nb">len</span><span class="p">(</span><span class="n">l</span><span class="p">[</span><span class="mi">1</span><span class="p">])]</span> <span class="o">=</span> <span class="n">l</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

    <span class="c1"># Mask the estimated Kdp and reconstructed Phidp with the mask of original</span>
    <span class="c1"># psidp</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">psidp_o</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">masked_array</span><span class="p">):</span>
        <span class="n">masked</span> <span class="o">=</span> <span class="n">psidp_o</span><span class="o">.</span><span class="n">mask</span>
        <span class="n">kdp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">kdp</span><span class="p">,</span> <span class="n">mask</span><span class="o">=</span><span class="n">masked</span><span class="p">,</span> <span class="n">fill_value</span><span class="o">=</span><span class="n">fill_value</span><span class="p">)</span>
        <span class="n">phidp_rec</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">phidp_rec</span><span class="p">,</span> <span class="n">mask</span><span class="o">=</span><span class="n">masked</span><span class="p">,</span> <span class="n">fill_value</span><span class="o">=</span><span class="n">fill_value</span><span class="p">)</span>

    <span class="c1"># create specific differential phase field dictionary and store data</span>
    <span class="n">kdp_dict</span> <span class="o">=</span> <span class="n">get_metadata</span><span class="p">(</span><span class="n">kdp_field</span><span class="p">)</span>
    <span class="n">kdp_dict</span><span class="p">[</span><span class="s1">&#39;data&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">kdp</span>
    <span class="c1"># kdp_dict[&#39;valid_min&#39;] = 0.0</span>

    <span class="c1"># create reconstructed differential phase field dictionary and store data</span>
    <span class="n">phidpr_dict</span> <span class="o">=</span> <span class="n">get_metadata</span><span class="p">(</span><span class="n">phidp_field</span><span class="p">)</span>
    <span class="n">phidpr_dict</span><span class="p">[</span><span class="s1">&#39;data&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">phidp_rec</span>
    <span class="c1"># phidpr_dict[&#39;valid_min&#39;] = 0.0</span>

    <span class="k">if</span> <span class="n">parallel</span><span class="p">:</span>
        <span class="n">pool</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>

    <span class="k">return</span> <span class="n">kdp_dict</span><span class="p">,</span> <span class="n">phidpr_dict</span></div>


<span class="k">def</span> <span class="nf">_kdp_vulpiani_profile</span><span class="p">(</span><span class="n">psidp_in</span><span class="p">,</span> <span class="n">dr</span><span class="p">,</span> <span class="n">windsize</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span>
                          <span class="n">band</span><span class="o">=</span><span class="s1">&#39;X&#39;</span><span class="p">,</span> <span class="n">n_iter</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">interp</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Estimates Kdp with the Vulpiani method for a single profile of psidp</span>
<span class="sd">    measurements</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    psidp_in : ndarray</span>
<span class="sd">        Total differential phase measurements.</span>
<span class="sd">    dr : float</span>
<span class="sd">        Range resolution in meters.</span>
<span class="sd">    windsize : int, optional</span>
<span class="sd">        Size in # of gates of the range derivative window.</span>
<span class="sd">    band : char, optional</span>
<span class="sd">        Radar frequency band string. Accepted &quot;X&quot;, &quot;C&quot;, &quot;S&quot; (capital</span>
<span class="sd">        or not). It is used to set default boundaries for expected</span>
<span class="sd">        values of Kdp</span>
<span class="sd">    n_iter : int, optional</span>
<span class="sd">        Number of iterations of the method. Default is 10.</span>
<span class="sd">    interp : bool, optional</span>
<span class="sd">        If set all the nans are interpolated.The advantage is that less data</span>
<span class="sd">        are lost (the iterations in fact are &quot;eating the edges&quot;) but some</span>
<span class="sd">        non-linear errors may be introduced</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    kdp_calc : ndarray</span>
<span class="sd">        Retrieved specific differential profile</span>
<span class="sd">    phidp_rec,: ndarray</span>
<span class="sd">        Retrieved differential phase profile</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">getmaskarray</span><span class="p">(</span><span class="n">psidp_in</span><span class="p">)</span>
    <span class="n">l</span> <span class="o">=</span> <span class="n">windsize</span>
    <span class="n">l2</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">l</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span>
    <span class="n">drm</span> <span class="o">=</span> <span class="n">dr</span><span class="o">/</span><span class="mf">1000.</span>

    <span class="k">if</span> <span class="n">mask</span><span class="o">.</span><span class="n">all</span><span class="p">()</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
        <span class="c1"># Check if all elements are masked</span>
        <span class="k">return</span> <span class="n">psidp_in</span><span class="p">,</span> <span class="n">psidp_in</span><span class="p">,</span> <span class="n">psidp_in</span>  <span class="c1"># Return the NaNs...</span>

    <span class="c1"># Thresholds in kdp calculation</span>
    <span class="k">if</span> <span class="n">band</span> <span class="o">==</span> <span class="s1">&#39;X&#39;</span><span class="p">:</span>
        <span class="n">th1</span> <span class="o">=</span> <span class="o">-</span><span class="mf">2.</span>
        <span class="n">th2</span> <span class="o">=</span> <span class="mf">40.</span>
        <span class="n">std_th</span> <span class="o">=</span> <span class="mf">5.</span>
    <span class="k">elif</span> <span class="n">band</span> <span class="o">==</span> <span class="s1">&#39;C&#39;</span><span class="p">:</span>
        <span class="n">th1</span> <span class="o">=</span> <span class="o">-</span><span class="mf">2.</span>
        <span class="n">th2</span> <span class="o">=</span> <span class="mf">20.</span>
        <span class="n">std_th</span> <span class="o">=</span> <span class="mf">5.</span>
    <span class="k">elif</span> <span class="n">band</span> <span class="o">==</span> <span class="s1">&#39;S&#39;</span><span class="p">:</span>
        <span class="n">th1</span> <span class="o">=</span> <span class="o">-</span><span class="mf">2.</span>
        <span class="n">th2</span> <span class="o">=</span> <span class="mf">14.</span>
        <span class="n">std_th</span> <span class="o">=</span> <span class="mf">5.</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Unexpected value set for the band keyword &#39;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">band</span><span class="p">)</span>
        <span class="k">return</span> <span class="kc">None</span>

    <span class="n">psidp</span> <span class="o">=</span> <span class="n">psidp_in</span>
    <span class="n">nn</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">psidp_in</span><span class="p">)</span>

    <span class="c1"># Get information of valid and non valid points in psidp the new psidp</span>
    <span class="n">valid</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_not</span><span class="p">(</span><span class="n">mask</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">interp</span><span class="p">:</span>
        <span class="n">ranged</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">nn</span><span class="p">)</span>
        <span class="n">psidp_interp</span> <span class="o">=</span> <span class="n">psidp</span>
        <span class="c1"># interpolate</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">is_masked</span><span class="p">(</span><span class="n">psidp</span><span class="p">):</span>
            <span class="n">interp</span> <span class="o">=</span> <span class="n">interpolate</span><span class="o">.</span><span class="n">interp1d</span><span class="p">(</span><span class="n">ranged</span><span class="p">[</span><span class="n">valid</span><span class="p">],</span> <span class="n">psidp</span><span class="p">[</span><span class="n">valid</span><span class="p">],</span>
                                          <span class="n">kind</span><span class="o">=</span><span class="s1">&#39;zero&#39;</span><span class="p">,</span> <span class="n">bounds_error</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                                          <span class="n">fill_value</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>
            <span class="n">psidp_interp</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span> <span class="o">=</span> <span class="n">interp</span><span class="p">(</span><span class="n">ranged</span><span class="p">[</span><span class="n">mask</span><span class="p">])</span>

        <span class="n">psidp</span> <span class="o">=</span> <span class="n">psidp_interp</span>

    <span class="n">psidp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">filled</span><span class="p">(</span><span class="n">psidp</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>
    <span class="n">kdp_calc</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">([</span><span class="n">nn</span><span class="p">])</span>

    <span class="c1"># first guess</span>
    <span class="c1"># In the core of the profile</span>
    <span class="n">kdp_calc</span><span class="p">[</span><span class="n">l2</span><span class="p">:</span><span class="n">nn</span><span class="o">-</span><span class="n">l2</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">psidp</span><span class="p">[</span><span class="n">l</span><span class="p">:</span><span class="n">nn</span><span class="p">]</span><span class="o">-</span><span class="n">psidp</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="n">nn</span><span class="o">-</span><span class="n">l</span><span class="p">])</span><span class="o">/</span><span class="p">(</span><span class="mf">2.</span><span class="o">*</span><span class="n">l</span><span class="o">*</span><span class="n">drm</span><span class="p">)</span>

    <span class="c1"># set ray extremes to 0</span>
    <span class="n">kdp_calc</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="n">l2</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.</span>
    <span class="n">kdp_calc</span><span class="p">[</span><span class="n">nn</span><span class="o">-</span><span class="n">l2</span><span class="p">:]</span> <span class="o">=</span> <span class="mf">0.</span>

    <span class="c1"># apply thresholds</span>
    <span class="n">kdp_calc</span><span class="p">[</span><span class="n">kdp_calc</span> <span class="o">&lt;=</span> <span class="n">th1</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.</span>
    <span class="n">kdp_calc</span><span class="p">[</span><span class="n">kdp_calc</span> <span class="o">&gt;=</span> <span class="n">th2</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.</span>

    <span class="c1"># set all non-valid data to 0</span>
    <span class="n">kdp_calc</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">kdp_calc</span><span class="p">)]</span> <span class="o">=</span> <span class="mf">0.</span>

    <span class="c1"># Remove bins with texture higher than treshold</span>
    <span class="n">tex</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">kdp_calc</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
    <span class="c1"># compute the local standard deviation</span>
    <span class="c1"># (make sure that it is and odd window)</span>
    <span class="n">tex_aux</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">rolling_window</span><span class="p">(</span><span class="n">kdp_calc</span><span class="p">,</span> <span class="n">l2</span><span class="o">*</span><span class="mi">2</span><span class="o">+</span><span class="mi">1</span><span class="p">),</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">tex</span><span class="p">[</span><span class="n">l2</span><span class="p">:</span><span class="o">-</span><span class="n">l2</span><span class="p">]</span> <span class="o">=</span> <span class="n">tex_aux</span>
    <span class="n">kdp_calc</span><span class="p">[</span><span class="n">tex</span> <span class="o">&gt;</span> <span class="n">std_th</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.</span>

    <span class="c1"># Loop over iterations</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">n_iter</span><span class="p">):</span>
        <span class="n">phidp_rec</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">cumsum</span><span class="p">(</span><span class="n">kdp_calc</span><span class="p">)</span><span class="o">*</span><span class="mf">2.</span><span class="o">*</span><span class="n">drm</span>

        <span class="c1"># In the core of the profile</span>
        <span class="n">kdp_calc</span><span class="p">[</span><span class="n">l2</span><span class="p">:</span><span class="n">nn</span><span class="o">-</span><span class="n">l2</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">phidp_rec</span><span class="p">[</span><span class="n">l</span><span class="p">:</span><span class="n">nn</span><span class="p">]</span><span class="o">-</span><span class="n">phidp_rec</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="n">nn</span><span class="o">-</span><span class="n">l</span><span class="p">])</span><span class="o">/</span><span class="p">(</span><span class="mf">2.</span><span class="o">*</span><span class="n">l</span><span class="o">*</span><span class="n">drm</span><span class="p">)</span>

        <span class="c1"># set ray extremes to 0</span>
        <span class="n">kdp_calc</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="n">l2</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.</span>
        <span class="n">kdp_calc</span><span class="p">[</span><span class="n">nn</span><span class="o">-</span><span class="n">l2</span><span class="p">:]</span> <span class="o">=</span> <span class="mf">0.</span>

        <span class="c1"># apply thresholds</span>
        <span class="n">kdp_calc</span><span class="p">[</span><span class="n">kdp_calc</span> <span class="o">&lt;=</span> <span class="n">th1</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.</span>
        <span class="n">kdp_calc</span><span class="p">[</span><span class="n">kdp_calc</span> <span class="o">&gt;=</span> <span class="n">th2</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.</span>

    <span class="c1"># Censor Kdp where Psidp was not defined</span>
    <span class="n">kdp_calc</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">masked_where</span><span class="p">(</span><span class="n">mask</span><span class="p">,</span> <span class="n">kdp_calc</span><span class="p">)</span>

    <span class="c1"># final reconstructed PhiDP from KDP</span>
    <span class="n">phidp_rec</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">cumsum</span><span class="p">(</span><span class="n">kdp_calc</span><span class="p">)</span><span class="o">*</span><span class="mf">2.</span><span class="o">*</span><span class="n">drm</span>

    <span class="k">return</span> <span class="n">kdp_calc</span><span class="p">,</span> <span class="n">phidp_rec</span>


<span class="k">def</span> <span class="nf">filter_psidp</span><span class="p">(</span><span class="n">radar</span><span class="p">,</span> <span class="n">psidp_field</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">rhohv_field</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">minsize_seq</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span>
                 <span class="n">median_filter_size</span><span class="o">=</span><span class="mi">7</span><span class="p">,</span> <span class="n">thresh_rhohv</span><span class="o">=</span><span class="mf">0.65</span><span class="p">,</span> <span class="n">max_discont</span><span class="o">=</span><span class="mi">90</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Filter measured psidp to remove spurious data in four steps:</span>
<span class="sd">         1. Censor it where Rhohv is lower than threshold</span>
<span class="sd">         2. Unravel angles when strong discontinuities are detected</span>
<span class="sd">         3. Remove very short sequences of valid data</span>
<span class="sd">         4. Apply a median filter on every profile</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    radar : Radar</span>
<span class="sd">        Radar containing differential phase field.</span>
<span class="sd">    psidp_field : str, optional</span>
<span class="sd">        Total differential phase field. If None, the default field name must be</span>
<span class="sd">        specified in the Py-ART configuration file.</span>
<span class="sd">    rhohv_field : str, optional</span>
<span class="sd">        Cross correlation ratio field. If None, the default field name must</span>
<span class="sd">        be specified in the Py-ART configuration file.</span>
<span class="sd">    minsize_seq  : integer, optional</span>
<span class="sd">        Minimal len (in radar gates) of sequences of valid data to be accepted</span>
<span class="sd">    median_filter_size : integer, optional</span>
<span class="sd">        Size (in radar gates) of the median filter to be applied on psidp</span>
<span class="sd">    thresh_rhohv : float, optional</span>
<span class="sd">        Censoring threshold in rhohv (gates with rhohv &lt; thresh_rhohv)</span>
<span class="sd">        will be rejected</span>
<span class="sd">    max_discont : int, optional</span>
<span class="sd">        Maximum discontinuity between psidp values, default is 90 deg</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    psidp_filt : ndarray</span>
<span class="sd">        Filtered psidp field</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># parse field names</span>
    <span class="k">if</span> <span class="n">psidp_field</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">psidp_field</span> <span class="o">=</span> <span class="n">get_field_name</span><span class="p">(</span><span class="s1">&#39;differential_phase&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">rhohv_field</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">rhohv_field</span> <span class="o">=</span> <span class="n">get_field_name</span><span class="p">(</span><span class="s1">&#39;cross_correlation_ratio&#39;</span><span class="p">)</span>

    <span class="c1"># parse total differential phase and cross corr. measurements</span>
    <span class="n">psidp_o</span> <span class="o">=</span> <span class="n">radar</span><span class="o">.</span><span class="n">fields</span><span class="p">[</span><span class="n">psidp_field</span><span class="p">][</span><span class="s1">&#39;data&#39;</span><span class="p">]</span>
    <span class="n">rhohv</span> <span class="o">=</span> <span class="n">radar</span><span class="o">.</span><span class="n">fields</span><span class="p">[</span><span class="n">rhohv_field</span><span class="p">][</span><span class="s1">&#39;data&#39;</span><span class="p">]</span>

    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">isscalar</span><span class="p">(</span><span class="n">psidp_o</span><span class="o">.</span><span class="n">mask</span><span class="p">):</span> <span class="c1"># Ensure 2D mask</span>
        <span class="n">psidp_o</span><span class="o">.</span><span class="n">mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">psidp_o</span><span class="o">.</span><span class="n">shape</span><span class="p">))</span> <span class="o">+</span> <span class="n">psidp_o</span><span class="o">.</span><span class="n">mask</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">psidp_o</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">masked_array</span><span class="p">):</span>
        <span class="n">psidp_o</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">psidp_o</span><span class="p">,</span> <span class="n">mask</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">psidp_o</span><span class="p">))</span>

    <span class="c1"># Initialize mask</span>
    <span class="n">mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">psidp_o</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">*</span> <span class="kc">False</span>

    <span class="c1"># Condition on rhohv</span>
    <span class="n">mask</span> <span class="o">+=</span> <span class="n">rhohv</span> <span class="o">&lt;</span> <span class="n">thresh_rhohv</span>
    <span class="c1"># Get original mask</span>
    <span class="n">mask</span> <span class="o">+=</span> <span class="n">psidp_o</span><span class="o">.</span><span class="n">mask</span>

    <span class="c1"># Remove short sequences and unwrap</span>
    <span class="n">psidp_filt</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">psidp_o</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">psi_row</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">psidp_o</span><span class="p">):</span>
        <span class="n">idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="o">~</span><span class="n">psi_row</span><span class="o">.</span><span class="n">mask</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>  <span class="c1"># idx of last valid gate</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">idx</span><span class="p">):</span>
            <span class="n">psi_row</span> <span class="o">=</span> <span class="n">psi_row</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="n">idx</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>
            <span class="n">psi_row</span><span class="p">[</span><span class="o">~</span><span class="n">psi_row</span><span class="o">.</span><span class="n">mask</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">rad2deg</span><span class="p">(</span>
                <span class="n">np</span><span class="o">.</span><span class="n">unwrap</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">deg2rad</span><span class="p">(</span><span class="n">psi_row</span><span class="p">[</span><span class="o">~</span><span class="n">psi_row</span><span class="o">.</span><span class="n">mask</span><span class="p">]),</span>
                          <span class="n">np</span><span class="o">.</span><span class="n">deg2rad</span><span class="p">(</span><span class="n">max_discont</span><span class="p">)))</span>
            <span class="n">psi_row_with_nan</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">filled</span><span class="p">(</span><span class="n">psi_row</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>
            <span class="c1"># To be sure to always have a left and right neighbour,</span>
            <span class="c1"># we need to pad the signal with NaN</span>
            <span class="n">psi_row_with_nan</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">pad</span><span class="p">(</span>
                <span class="n">psi_row_with_nan</span><span class="p">,</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="s1">&#39;constant&#39;</span><span class="p">,</span> <span class="n">constant_values</span><span class="o">=</span><span class="p">(</span>
                    <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,))</span>
            <span class="n">idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">psi_row_with_nan</span><span class="p">))[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">nan_left</span> <span class="o">=</span> <span class="n">idx</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">psi_row_with_nan</span><span class="p">[</span><span class="n">idx</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]))[</span><span class="mi">0</span><span class="p">]]</span>
            <span class="n">nan_right</span> <span class="o">=</span> <span class="n">idx</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">psi_row_with_nan</span><span class="p">[</span><span class="n">idx</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]))[</span><span class="mi">0</span><span class="p">]]</span>

            <span class="n">len_sub</span> <span class="o">=</span> <span class="n">nan_right</span> <span class="o">-</span> <span class="n">nan_left</span>

            <span class="k">for</span> <span class="n">j</span><span class="p">,</span> <span class="n">l</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">len_sub</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">l</span> <span class="o">&lt;</span> <span class="n">minsize_seq</span><span class="p">:</span>
                    <span class="n">mask</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">nan_left</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span><span class="n">nan_right</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>

            <span class="c1"># median filter</span>
            <span class="n">psi_row</span> <span class="o">=</span> <span class="n">signal</span><span class="o">.</span><span class="n">medfilt</span><span class="p">(</span><span class="n">psi_row_with_nan</span><span class="p">,</span> <span class="n">median_filter_size</span><span class="p">)</span>
            <span class="n">psidp_filt</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="mi">0</span><span class="p">:</span><span class="nb">len</span><span class="p">(</span><span class="n">psi_row</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">])]</span> <span class="o">=</span> <span class="n">psi_row</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

    <span class="n">psidp_filt</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">masked_array</span><span class="p">(</span>
        <span class="n">psidp_filt</span><span class="p">,</span> <span class="n">mask</span><span class="o">=</span><span class="n">mask</span><span class="p">,</span> <span class="n">fill_value</span><span class="o">=</span><span class="n">psidp_o</span><span class="o">.</span><span class="n">fill_value</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">psidp_filt</span>


<span class="c1"># Necessary and/or potential future improvements to the KDP module:</span>
<span class="c1">#</span>
<span class="c1"># * The near and far range gate boundary conditions necessary for the Maesaka</span>
<span class="c1">#   et al. (2012) variational method are sensitive to the number of range gates</span>
<span class="c1">#   used to define both boundaries as well as outliers in these samples. This</span>
<span class="c1">#   may have to be further investigated and potentially improved upon.</span>
<span class="c1">#</span>
<span class="c1"># * It would be beneficial for the GateFilter class to have a method which can</span>
<span class="c1">#   flag radar gates above the melting layer, maybe through the user supplying</span>
<span class="c1">#   an estimate of the 0 deg Celsius level above mean sea level.</span>
<span class="c1">#</span>
<span class="c1"># * The backscatter differential phase parameter will likely have to be updated</span>
<span class="c1">#   in the future to handle various parameterizations.</span>
<span class="c1">#</span>
<span class="c1"># * The addition of an azimuthal low-pass filter (smoothness) constraint would</span>
<span class="c1">#   be beneficial to the variational Maesaka et al. (2012) algorithm.</span>
<span class="c1">#</span>
<span class="c1"># * Add the ability to record and/or store minimization data, e.g., current</span>
<span class="c1">#   iteration number, functional value and functional gradient norm value as a</span>
<span class="c1">#   function of iteration.</span>


<div class="viewcode-block" id="kdp_maesaka"><a class="viewcode-back" href="../../../API/generated/pyart.retrieve.kdp_maesaka.html#pyart.retrieve.kdp_maesaka">[docs]</a><span class="k">def</span> <span class="nf">kdp_maesaka</span><span class="p">(</span><span class="n">radar</span><span class="p">,</span> <span class="n">gatefilter</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s1">&#39;cg&#39;</span><span class="p">,</span> <span class="n">backscatter</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                <span class="n">Clpf</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span> <span class="n">length_scale</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">first_guess</span><span class="o">=</span><span class="mf">0.01</span><span class="p">,</span>
                <span class="n">finite_order</span><span class="o">=</span><span class="s1">&#39;low&#39;</span><span class="p">,</span> <span class="n">fill_value</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">proc</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">psidp_field</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                <span class="n">kdp_field</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">phidp_field</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">debug</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compute the specific differential phase (KDP) from corrected (e.g.,</span>
<span class="sd">    unfolded) total differential phase data based on the variational method</span>
<span class="sd">    outlined in Maesaka et al. (2012). This method assumes a monotonically</span>
<span class="sd">    increasing propagation differential phase (PHIDP) with increasing range</span>
<span class="sd">    from the radar, and therefore is limited to rainfall below the melting</span>
<span class="sd">    layer and/or warm clouds at weather radar frequencies (e.g., S-, C-, and</span>
<span class="sd">    X-band). This method currently only supports radar data with constant range</span>
<span class="sd">    resolution.</span>

<span class="sd">    Following the notation of Maesaka et al. (2012), the primary control</span>
<span class="sd">    variable k is proportional to KDP,</span>

<span class="sd">                                k**2 = 2 * KDP * dr</span>

<span class="sd">    which, because of the square, assumes that KDP always takes a positive</span>
<span class="sd">    value.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    radar : Radar</span>
<span class="sd">        Radar containing differential phase field.</span>
<span class="sd">    gatefilter : GateFilter</span>
<span class="sd">        A GateFilter indicating radar gates that should be excluded when</span>
<span class="sd">        analysing differential phase measurements.</span>
<span class="sd">    method : str, optional</span>
<span class="sd">        Type of scipy.optimize method to use when minimizing the cost</span>
<span class="sd">        functional. The default method uses a nonlinear conjugate gradient</span>
<span class="sd">        algorithm. In Maesaka et al. (2012) they use the Broyden-Fletcher-</span>
<span class="sd">        Goldfarb-Shanno (BFGS) algorithm, however for large functional size</span>
<span class="sd">        (e.g., 100K+ variables) this algorithm is considerably slower than a</span>
<span class="sd">        conjugate gradient algorithm.</span>
<span class="sd">    backscatter : optional</span>
<span class="sd">        Define the backscatter differential phase. If None, the backscatter</span>
<span class="sd">        differential phase is set to zero for all range gates. Note that</span>
<span class="sd">        backscatter differential phase can be parameterized using attentuation</span>
<span class="sd">        corrected differential reflectivity.</span>
<span class="sd">    Clpf : float, optional</span>
<span class="sd">        The low-pass filter (radial smoothness) constraint weight as in</span>
<span class="sd">        equation (15) of Maesaka et al. (2012).</span>
<span class="sd">    length_scale : float, optional</span>
<span class="sd">        Length scale in meters used to bring the dimension and magnitude of the</span>
<span class="sd">        low-pass filter cost functional in line with the observation cost</span>
<span class="sd">        functional. If None, the length scale is set to the range resolution.</span>
<span class="sd">    first_guess : float, optional</span>
<span class="sd">        First guess for control variable k. Since k is proportional to the</span>
<span class="sd">        square root of KDP, the first guess should be close to zero to signify</span>
<span class="sd">        a KDP field close to 0 deg/km everywhere. However, the first guess</span>
<span class="sd">        should not be exactly zero in order to avoid convergence criteria after</span>
<span class="sd">        the first iteration. In fact it is recommended to use a value closer to</span>
<span class="sd">        one than zero.</span>
<span class="sd">    finite_order : &#39;low&#39; or &#39;high&#39;, optional</span>
<span class="sd">        The finite difference accuracy to use when computing derivatives.</span>
<span class="sd">    maxiter : int, optional</span>
<span class="sd">        Maximum number of iterations to perform during cost functional</span>
<span class="sd">        minimization. The maximum number of iterations are only performed if</span>
<span class="sd">        convergence criteria are not met. For variational schemes such as this</span>
<span class="sd">        one, it is generally not recommended to try and achieve convergence</span>
<span class="sd">        criteria since the values of the cost functional and/or its gradient</span>
<span class="sd">        norm are somewhat arbitrary.</span>
<span class="sd">    fill_value : float, optional</span>
<span class="sd">        Value indicating missing or bad data in differential phase field.</span>
<span class="sd">    proc : int, optional</span>
<span class="sd">        The number of parallel threads (CPUs) to use. Currently no</span>
<span class="sd">        multiprocessing capability exists.</span>
<span class="sd">    psidp_field : str, optional</span>
<span class="sd">        Total differential phase field. If None, the default field name must be</span>
<span class="sd">        specified in the Py-ART configuration file.</span>
<span class="sd">    kdp_field : str, optional</span>
<span class="sd">        Specific differential phase field. If None, the default field name must</span>
<span class="sd">        be specified in the Py-ART configuration file.</span>
<span class="sd">    phidp_field : str, optional</span>
<span class="sd">        Propagation differential phase field. If None, the default field name</span>
<span class="sd">        must be specified in the Py-ART configuration file.</span>
<span class="sd">    debug : bool, optional</span>
<span class="sd">        True to print debugging information, False to suppress.</span>
<span class="sd">    verbose : bool, optional</span>
<span class="sd">        True to print relevant information, False to suppress.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    kdp_dict : dict</span>
<span class="sd">        Retrieved specific differential phase data and metadata.</span>
<span class="sd">    phidpf_dict, phidpr_dict : dict</span>
<span class="sd">        Retrieved forward and reverse direction propagation differential phase</span>
<span class="sd">        data and metadata.</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    Maesaka, T., Iwanami, K. and Maki, M., 2012: &quot;Non-negative KDP Estimation</span>
<span class="sd">    by Monotone Increasing PHIDP Assumption below Melting Layer&quot;. The Seventh</span>
<span class="sd">    European Conference on Radar in Meteorology and Hydrology.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># parse fill value</span>
    <span class="k">if</span> <span class="n">fill_value</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">fill_value</span> <span class="o">=</span> <span class="n">get_fillvalue</span><span class="p">()</span>

    <span class="c1"># parse field names</span>
    <span class="k">if</span> <span class="n">psidp_field</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">psidp_field</span> <span class="o">=</span> <span class="n">get_field_name</span><span class="p">(</span><span class="s1">&#39;differential_phase&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">kdp_field</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">kdp_field</span> <span class="o">=</span> <span class="n">get_field_name</span><span class="p">(</span><span class="s1">&#39;specific_differential_phase&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">phidp_field</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">phidp_field</span> <span class="o">=</span> <span class="n">get_field_name</span><span class="p">(</span><span class="s1">&#39;differential_phase&#39;</span><span class="p">)</span>

    <span class="c1"># parse range resolution, length scale and low-pass filter constraint</span>
    <span class="c1"># weight</span>
    <span class="n">dr</span> <span class="o">=</span> <span class="n">_parse_range_resolution</span><span class="p">(</span><span class="n">radar</span><span class="p">,</span> <span class="n">check_uniform</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">)</span>

    <span class="c1"># parse length scale</span>
    <span class="k">if</span> <span class="n">length_scale</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">length_scale</span> <span class="o">=</span> <span class="n">dr</span>

    <span class="c1"># parse low-pass filter constraint weight</span>
    <span class="c1"># this brings the dimensions and magnitude of the low-pass filter</span>
    <span class="c1"># constraint in line with the differential phase measurement constraint</span>
    <span class="n">Clpf</span> <span class="o">*=</span> <span class="n">length_scale</span><span class="o">**</span><span class="mi">4</span>

    <span class="c1"># parse near and far range gate propagation differential phase boundary</span>
    <span class="c1"># conditions</span>
    <span class="n">bcs</span> <span class="o">=</span> <span class="n">boundary_conditions_maesaka</span><span class="p">(</span>
        <span class="n">radar</span><span class="p">,</span> <span class="n">gatefilter</span><span class="o">=</span><span class="n">gatefilter</span><span class="p">,</span> <span class="n">psidp_field</span><span class="o">=</span><span class="n">psidp_field</span><span class="p">,</span> <span class="n">debug</span><span class="o">=</span><span class="n">debug</span><span class="p">,</span>
        <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
    <span class="n">phi_near</span><span class="p">,</span> <span class="n">phi_far</span> <span class="o">=</span> <span class="n">bcs</span><span class="p">[:</span><span class="mi">2</span><span class="p">]</span>
    <span class="n">idx_near</span><span class="p">,</span> <span class="n">idx_far</span> <span class="o">=</span> <span class="n">bcs</span><span class="p">[</span><span class="mi">4</span><span class="p">:]</span>

    <span class="c1"># parse total differential phase measurements</span>
    <span class="n">psidp_o</span> <span class="o">=</span> <span class="n">radar</span><span class="o">.</span><span class="n">fields</span><span class="p">[</span><span class="n">psidp_field</span><span class="p">][</span><span class="s1">&#39;data&#39;</span><span class="p">]</span>

    <span class="k">if</span> <span class="n">debug</span><span class="p">:</span>
        <span class="n">N</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">count</span><span class="p">(</span><span class="n">psidp_o</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Sample size before filtering: </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">N</span><span class="p">))</span>

    <span class="c1"># mask radar gates indicated by the gate filter</span>
    <span class="k">if</span> <span class="n">gatefilter</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">psidp_o</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">masked_where</span><span class="p">(</span><span class="n">gatefilter</span><span class="o">.</span><span class="n">gate_excluded</span><span class="p">,</span> <span class="n">psidp_o</span><span class="p">)</span>

    <span class="c1"># mask any radar gates which are closer (further) than the near (far)</span>
    <span class="c1"># boundary condition ranges</span>
    <span class="k">for</span> <span class="n">ray</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">radar</span><span class="o">.</span><span class="n">nrays</span><span class="p">):</span>
        <span class="n">psidp_o</span><span class="p">[</span><span class="n">ray</span><span class="p">,</span> <span class="p">:</span><span class="n">idx_near</span><span class="p">[</span><span class="n">ray</span><span class="p">]]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">masked</span>
        <span class="n">psidp_o</span><span class="p">[</span><span class="n">ray</span><span class="p">,</span> <span class="n">idx_far</span><span class="p">[</span><span class="n">ray</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">masked</span>

    <span class="k">if</span> <span class="n">debug</span><span class="p">:</span>
        <span class="n">N</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">count</span><span class="p">(</span><span class="n">psidp_o</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Sample size after filtering: </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">N</span><span class="p">))</span>

    <span class="c1"># parse differential phase measurement weight</span>
    <span class="n">Cobs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_not</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">getmaskarray</span><span class="p">(</span><span class="n">psidp_o</span><span class="p">))</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">psidp_o</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
    <span class="n">psidp_o</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">filled</span><span class="p">(</span><span class="n">psidp_o</span><span class="p">,</span> <span class="n">fill_value</span><span class="p">)</span>

    <span class="c1"># parse backscattered differential phase data</span>
    <span class="k">if</span> <span class="n">backscatter</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">dhv</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">psidp_o</span><span class="p">,</span> <span class="n">subok</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

    <span class="c1"># parse solver options</span>
    <span class="n">options</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s1">&#39;maxiter&#39;</span><span class="p">:</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;maxiter&#39;</span><span class="p">,</span> <span class="mi">50</span><span class="p">),</span>
        <span class="s1">&#39;gtol&#39;</span><span class="p">:</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;gtol&#39;</span><span class="p">,</span> <span class="mf">1.0e-5</span><span class="p">),</span>
        <span class="s1">&#39;disp&#39;</span><span class="p">:</span> <span class="n">verbose</span><span class="p">,</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="n">debug</span><span class="p">:</span>
        <span class="n">optimize</span><span class="o">.</span><span class="n">show_options</span><span class="p">(</span><span class="n">solver</span><span class="o">=</span><span class="s1">&#39;minimize&#39;</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="n">method</span><span class="p">)</span>

    <span class="c1"># parse initial conditions (first guess)</span>
    <span class="n">x0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">psidp_o</span><span class="p">,</span> <span class="n">subok</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>
    <span class="n">x0</span><span class="o">.</span><span class="n">fill</span><span class="p">(</span><span class="n">first_guess</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Cost functional size: </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">x0</span><span class="o">.</span><span class="n">size</span><span class="p">))</span>

    <span class="c1"># define arguments for cost functional and its Jacobian (gradient)</span>
    <span class="n">args</span> <span class="o">=</span> <span class="p">(</span><span class="n">psidp_o</span><span class="p">,</span> <span class="p">[</span><span class="n">phi_near</span><span class="p">,</span> <span class="n">phi_far</span><span class="p">],</span>
            <span class="n">dhv</span><span class="p">,</span> <span class="n">dr</span><span class="p">,</span> <span class="n">Cobs</span><span class="p">,</span> <span class="n">Clpf</span><span class="p">,</span>
            <span class="n">finite_order</span><span class="p">,</span> <span class="n">fill_value</span><span class="p">,</span>
            <span class="n">proc</span><span class="p">,</span> <span class="n">debug</span><span class="p">,</span> <span class="n">verbose</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">debug</span><span class="p">:</span>
        <span class="n">start</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>

    <span class="c1"># minimize the cost functional</span>
    <span class="n">xopt</span> <span class="o">=</span> <span class="n">optimize</span><span class="o">.</span><span class="n">minimize</span><span class="p">(</span>
        <span class="n">_cost_maesaka</span><span class="p">,</span> <span class="n">x0</span><span class="p">,</span> <span class="n">args</span><span class="o">=</span><span class="n">args</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="n">method</span><span class="p">,</span> <span class="n">jac</span><span class="o">=</span><span class="n">_jac_maesaka</span><span class="p">,</span>
        <span class="n">hess</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">hessp</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">bounds</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">constraints</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">callback</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">options</span><span class="o">=</span><span class="n">options</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">debug</span><span class="p">:</span>
        <span class="n">elapsed</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span> <span class="o">-</span> <span class="n">start</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Elapsed time for minimization: </span><span class="si">{:.0f}</span><span class="s1"> sec&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">elapsed</span><span class="p">))</span>

    <span class="c1"># parse control variables from optimized result</span>
    <span class="n">k</span> <span class="o">=</span> <span class="n">xopt</span><span class="o">.</span><span class="n">x</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">psidp_o</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>

    <span class="c1"># compute specific differential phase from control variable k in deg/km</span>
    <span class="n">kdp</span> <span class="o">=</span> <span class="n">k</span><span class="o">**</span><span class="mi">2</span> <span class="o">/</span> <span class="p">(</span><span class="mf">2.0</span> <span class="o">*</span> <span class="n">dr</span><span class="p">)</span> <span class="o">*</span> <span class="mf">1000.0</span>

    <span class="k">if</span> <span class="n">debug</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Min retrieved KDP: </span><span class="si">{:.2f}</span><span class="s1"> deg/km&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">kdp</span><span class="o">.</span><span class="n">min</span><span class="p">()))</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Max retrieved KDP: </span><span class="si">{:.2f}</span><span class="s1"> deg/km&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">kdp</span><span class="o">.</span><span class="n">max</span><span class="p">()))</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Mean retrieved KDP: </span><span class="si">{:.2f}</span><span class="s1"> deg/km&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">kdp</span><span class="o">.</span><span class="n">mean</span><span class="p">()))</span>

    <span class="c1"># create specific differential phase field dictionary and store data</span>
    <span class="n">kdp_dict</span> <span class="o">=</span> <span class="n">get_metadata</span><span class="p">(</span><span class="n">kdp_field</span><span class="p">)</span>
    <span class="n">kdp_dict</span><span class="p">[</span><span class="s1">&#39;data&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">kdp</span>
    <span class="n">kdp_dict</span><span class="p">[</span><span class="s1">&#39;valid_min&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.0</span>
    <span class="n">kdp_dict</span><span class="p">[</span><span class="s1">&#39;Clpf&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">Clpf</span>

    <span class="c1"># compute forward and reverse direction propagation differential phase</span>
    <span class="n">phidp_f</span><span class="p">,</span> <span class="n">phidp_r</span> <span class="o">=</span> <span class="n">_forward_reverse_phidp</span><span class="p">(</span>
        <span class="n">k</span><span class="p">,</span> <span class="p">[</span><span class="n">phi_near</span><span class="p">,</span> <span class="n">phi_far</span><span class="p">],</span> <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">)</span>

    <span class="c1"># create forward direction propagation differential phase field dictionary</span>
    <span class="c1"># and store data</span>
    <span class="n">phidpf_dict</span> <span class="o">=</span> <span class="n">get_metadata</span><span class="p">(</span><span class="n">phidp_field</span><span class="p">)</span>
    <span class="n">phidpf_dict</span><span class="p">[</span><span class="s1">&#39;data&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">phidp_f</span>
    <span class="n">phidpf_dict</span><span class="p">[</span><span class="s1">&#39;comment&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;Retrieved in forward direction&#39;</span>

    <span class="c1"># create reverse direction propagation differential phase field dictionary</span>
    <span class="c1"># and store data</span>
    <span class="n">phidpr_dict</span> <span class="o">=</span> <span class="n">get_metadata</span><span class="p">(</span><span class="n">phidp_field</span><span class="p">)</span>
    <span class="n">phidpr_dict</span><span class="p">[</span><span class="s1">&#39;data&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">phidp_r</span>
    <span class="n">phidpr_dict</span><span class="p">[</span><span class="s1">&#39;comment&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;Retrieved in reverse direction&#39;</span>

    <span class="k">return</span> <span class="n">kdp_dict</span><span class="p">,</span> <span class="n">phidpf_dict</span><span class="p">,</span> <span class="n">phidpr_dict</span></div>


<span class="k">def</span> <span class="nf">boundary_conditions_maesaka</span><span class="p">(</span>
        <span class="n">radar</span><span class="p">,</span> <span class="n">gatefilter</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="mi">20</span><span class="p">,</span> <span class="n">psidp_field</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">debug</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Determine near range gate and far range gate propagation differential phase</span>
<span class="sd">    boundary conditions. This follows the method outlined in Maesaka et al.</span>
<span class="sd">    (2012), except instead of using the mean we use the median which is less</span>
<span class="sd">    susceptible to outliers. This function can also be used to estimate the</span>
<span class="sd">    system phase offset.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    radar : Radar</span>
<span class="sd">        Radar containing total differential phase measurements.</span>
<span class="sd">    gatefilter : GateFilter</span>
<span class="sd">        A GateFilter indicating radar gates that should be excluded when</span>
<span class="sd">        analysing differential phase measurements.</span>
<span class="sd">    n : int, optional</span>
<span class="sd">        The number of range gates necessary to define the near and far range</span>
<span class="sd">        gate boundary conditions. Maesaka et al. (2012) uses a value of 30. If</span>
<span class="sd">        this value is too small then a spurious spike in specific differential</span>
<span class="sd">        phase close to the radar may be retrieved.</span>
<span class="sd">    check_outliers : bool, optional</span>
<span class="sd">        True to check for near range gate boundary condition outliers. Outliers</span>
<span class="sd">        near the radar are primarily the result of ground clutter returns.</span>
<span class="sd">    psidp_field : str, optional</span>
<span class="sd">        Field name of total differential phase. If None, the default field name</span>
<span class="sd">        must be specified in the Py-ART configuration file.</span>
<span class="sd">    debug : bool, optional</span>
<span class="sd">        True to print debugging information, False to suppress.</span>
<span class="sd">    verbose : bool, optional</span>
<span class="sd">        True to print relevant information, False to suppress.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    phi_near : ndarray</span>
<span class="sd">        The near range differential phase boundary condition for each ray.</span>
<span class="sd">    phi_far : ndarray</span>
<span class="sd">        The far range differential phase boundary condition for each ray.</span>
<span class="sd">    range_near : ndarray</span>
<span class="sd">        The near range gate in meters for each ray.</span>
<span class="sd">    range_far : ndarray</span>
<span class="sd">        The far range gate in meters for each ray.</span>
<span class="sd">    idx_near : ndarray</span>
<span class="sd">        Index of nearest range gate for each ray.</span>
<span class="sd">    idx_far : ndarray</span>
<span class="sd">        Index of furthest range gate for each ray.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># parse field names</span>
    <span class="k">if</span> <span class="n">psidp_field</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">psidp_field</span> <span class="o">=</span> <span class="n">get_field_name</span><span class="p">(</span><span class="s1">&#39;differential_phase&#39;</span><span class="p">)</span>

    <span class="c1"># parse differential phase measurements</span>
    <span class="n">psidp</span> <span class="o">=</span> <span class="n">radar</span><span class="o">.</span><span class="n">fields</span><span class="p">[</span><span class="n">psidp_field</span><span class="p">][</span><span class="s1">&#39;data&#39;</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">gatefilter</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">psidp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">masked_where</span><span class="p">(</span><span class="n">gatefilter</span><span class="o">.</span><span class="n">gate_excluded</span><span class="p">,</span> <span class="n">psidp</span><span class="p">)</span>

    <span class="c1"># find contiguous unmasked data along each ray</span>
    <span class="n">slices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">notmasked_contiguous</span><span class="p">(</span><span class="n">psidp</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">debug</span><span class="p">:</span>
        <span class="n">N</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">([</span><span class="nb">len</span><span class="p">(</span><span class="n">slc</span><span class="p">)</span> <span class="k">for</span> <span class="n">slc</span> <span class="ow">in</span> <span class="n">slices</span> <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">slc</span><span class="p">,</span> <span class="s1">&#39;__len__&#39;</span><span class="p">)])</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Total number of unique non-masked regions: </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">N</span><span class="p">))</span>

    <span class="n">phi_near</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">radar</span><span class="o">.</span><span class="n">nrays</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">psidp</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
    <span class="n">phi_far</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">radar</span><span class="o">.</span><span class="n">nrays</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">psidp</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
    <span class="n">range_near</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">radar</span><span class="o">.</span><span class="n">nrays</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">psidp</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
    <span class="n">range_far</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">radar</span><span class="o">.</span><span class="n">nrays</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">psidp</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
    <span class="n">idx_near</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">radar</span><span class="o">.</span><span class="n">nrays</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>
    <span class="n">idx_far</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">radar</span><span class="o">.</span><span class="n">nrays</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">ray</span><span class="p">,</span> <span class="n">regions</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">slices</span><span class="p">):</span>

        <span class="c1"># check if all range gates are missing</span>
        <span class="k">if</span> <span class="n">regions</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">continue</span>

        <span class="c1"># check if all range gates available, i.e., no masked data</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">regions</span><span class="p">,</span> <span class="nb">slice</span><span class="p">):</span>
            <span class="n">regions</span> <span class="o">=</span> <span class="p">[</span><span class="n">regions</span><span class="p">]</span>

        <span class="c1"># near range gate boundary condition</span>
        <span class="k">for</span> <span class="n">slc</span> <span class="ow">in</span> <span class="n">regions</span><span class="p">:</span>

            <span class="c1"># check if enough samples exist in slice</span>
            <span class="k">if</span> <span class="n">slc</span><span class="o">.</span><span class="n">stop</span> <span class="o">-</span> <span class="n">slc</span><span class="o">.</span><span class="n">start</span> <span class="o">&gt;=</span> <span class="n">n</span><span class="p">:</span>

                <span class="c1"># parse index and range of nearest range gate</span>
                <span class="n">idx</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="n">slc</span><span class="o">.</span><span class="n">start</span><span class="p">,</span> <span class="n">slc</span><span class="o">.</span><span class="n">start</span> <span class="o">+</span> <span class="n">n</span><span class="p">)</span>
                <span class="n">idx_near</span><span class="p">[</span><span class="n">ray</span><span class="p">]</span> <span class="o">=</span> <span class="n">idx</span><span class="o">.</span><span class="n">start</span>
                <span class="n">range_near</span><span class="p">[</span><span class="n">ray</span><span class="p">]</span> <span class="o">=</span> <span class="n">radar</span><span class="o">.</span><span class="n">range</span><span class="p">[</span><span class="s1">&#39;data&#39;</span><span class="p">][</span><span class="n">idx</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>

                <span class="c1"># parse data for linear regression and compute slope</span>
                <span class="n">x</span> <span class="o">=</span> <span class="n">radar</span><span class="o">.</span><span class="n">range</span><span class="p">[</span><span class="s1">&#39;data&#39;</span><span class="p">][</span><span class="n">idx</span><span class="p">]</span>
                <span class="n">y</span> <span class="o">=</span> <span class="n">psidp</span><span class="p">[</span><span class="n">ray</span><span class="p">,</span> <span class="n">idx</span><span class="p">]</span>
                <span class="n">slope</span> <span class="o">=</span> <span class="n">stats</span><span class="o">.</span><span class="n">linregress</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>

                <span class="c1"># if linear regression slope is positive, set near range gate</span>
                <span class="c1"># boundary condition to first differential phase measurement,</span>
                <span class="c1"># otherwise use the median value</span>
                <span class="k">if</span> <span class="n">slope</span> <span class="o">&gt;</span> <span class="mf">0.0</span><span class="p">:</span>
                    <span class="n">phi_near</span><span class="p">[</span><span class="n">ray</span><span class="p">]</span> <span class="o">=</span> <span class="n">y</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">phi_near</span><span class="p">[</span><span class="n">ray</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
                <span class="k">break</span>

            <span class="k">else</span><span class="p">:</span>
                <span class="k">continue</span>

        <span class="c1"># far range gate boundary condition</span>
        <span class="k">for</span> <span class="n">slc</span> <span class="ow">in</span> <span class="nb">reversed</span><span class="p">(</span><span class="n">regions</span><span class="p">):</span>

            <span class="k">if</span> <span class="n">slc</span><span class="o">.</span><span class="n">stop</span> <span class="o">-</span> <span class="n">slc</span><span class="o">.</span><span class="n">start</span> <span class="o">&gt;=</span> <span class="n">n</span><span class="p">:</span>

                <span class="c1"># parse index and range of furthest range gate</span>
                <span class="n">idx</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="n">slc</span><span class="o">.</span><span class="n">stop</span> <span class="o">-</span> <span class="n">n</span><span class="p">,</span> <span class="n">slc</span><span class="o">.</span><span class="n">stop</span><span class="p">)</span>
                <span class="n">idx_far</span><span class="p">[</span><span class="n">ray</span><span class="p">]</span> <span class="o">=</span> <span class="n">idx</span><span class="o">.</span><span class="n">stop</span>
                <span class="n">range_far</span><span class="p">[</span><span class="n">ray</span><span class="p">]</span> <span class="o">=</span> <span class="n">radar</span><span class="o">.</span><span class="n">range</span><span class="p">[</span><span class="s1">&#39;data&#39;</span><span class="p">][</span><span class="n">idx</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

                <span class="c1"># parse data for linear regression and compute slope</span>
                <span class="n">x</span> <span class="o">=</span> <span class="n">radar</span><span class="o">.</span><span class="n">range</span><span class="p">[</span><span class="s1">&#39;data&#39;</span><span class="p">][</span><span class="n">idx</span><span class="p">]</span>
                <span class="n">y</span> <span class="o">=</span> <span class="n">psidp</span><span class="p">[</span><span class="n">ray</span><span class="p">,</span> <span class="n">idx</span><span class="p">]</span>
                <span class="n">slope</span> <span class="o">=</span> <span class="n">stats</span><span class="o">.</span><span class="n">linregress</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>

                <span class="c1"># if linear regression slope is positive, set far range gate</span>
                <span class="c1"># boundary condition to last differential phase measurement,</span>
                <span class="c1"># otherwise use the median value</span>
                <span class="k">if</span> <span class="n">slope</span> <span class="o">&gt;</span> <span class="mf">0.0</span><span class="p">:</span>
                    <span class="n">phi_far</span><span class="p">[</span><span class="n">ray</span><span class="p">]</span> <span class="o">=</span> <span class="n">y</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">phi_far</span><span class="p">[</span><span class="n">ray</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
                <span class="k">break</span>

            <span class="k">else</span><span class="p">:</span>
                <span class="k">continue</span>

    <span class="c1"># check for outliers in the near range boundary conditions, e.g., ground</span>
    <span class="c1"># clutter can introduce spurious values in certain rays</span>

    <span class="c1"># do not include missing values in the analysis</span>
    <span class="n">phi_near_valid</span> <span class="o">=</span> <span class="n">phi_near</span><span class="p">[</span><span class="n">phi_near</span> <span class="o">!=</span> <span class="mf">0.0</span><span class="p">]</span>

    <span class="c1"># skip the check if there are no valid values</span>
    <span class="k">if</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;check_outliers&#39;</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">phi_near_valid</span><span class="o">.</span><span class="n">size</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">):</span>

        <span class="c1"># bin and count near range boundary condition values, i.e., create</span>
        <span class="c1"># a distribution of values</span>
        <span class="c1"># the default bin width is 5 deg</span>
        <span class="n">counts</span><span class="p">,</span> <span class="n">edges</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">histogram</span><span class="p">(</span>
            <span class="n">phi_near_valid</span><span class="p">,</span> <span class="n">bins</span><span class="o">=</span><span class="mi">144</span><span class="p">,</span> <span class="nb">range</span><span class="o">=</span><span class="p">(</span><span class="o">-</span><span class="mi">360</span><span class="p">,</span> <span class="mi">360</span><span class="p">),</span> <span class="n">density</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

        <span class="c1"># assume that the maximum counts corresponds to the maximum in the</span>
        <span class="c1"># system phase distribution</span>
        <span class="c1"># this assumption breaks down if there are a significant amount of</span>
        <span class="c1"># near range boundary conditions characterized by ground clutter</span>
        <span class="n">system_phase_peak_left</span> <span class="o">=</span> <span class="n">edges</span><span class="p">[</span><span class="n">counts</span><span class="o">.</span><span class="n">argmax</span><span class="p">()]</span>
        <span class="n">system_phase_peak_right</span> <span class="o">=</span> <span class="n">edges</span><span class="p">[</span><span class="n">counts</span><span class="o">.</span><span class="n">argmax</span><span class="p">()</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">debug</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Peak of system phase distribution: </span><span class="si">{:.0f}</span><span class="s1"> deg&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                <span class="n">system_phase_peak_left</span><span class="p">))</span>

        <span class="c1"># determine left edge location of system phase distribution</span>
        <span class="c1"># we consider five counts or less to be insignificant</span>
        <span class="n">is_left_side</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span>
            <span class="n">edges</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">system_phase_peak_left</span><span class="p">,</span> <span class="n">counts</span> <span class="o">&lt;=</span> <span class="mi">5</span><span class="p">)</span>
        <span class="n">left_edge</span> <span class="o">=</span> <span class="n">edges</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="n">is_left_side</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

        <span class="c1"># determine right edge location of system phase distribution</span>
        <span class="c1"># we consider five counts or less to be insignificant</span>
        <span class="n">is_right_side</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span>
            <span class="n">edges</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">&gt;</span> <span class="n">system_phase_peak_right</span><span class="p">,</span> <span class="n">counts</span> <span class="o">&lt;=</span> <span class="mi">5</span><span class="p">)</span>
        <span class="n">right_edge</span> <span class="o">=</span> <span class="n">edges</span><span class="p">[</span><span class="mi">1</span><span class="p">:][</span><span class="n">is_right_side</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">debug</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Left edge of system phase distribution: </span><span class="si">{:.0f}</span><span class="s1"> deg&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                <span class="n">left_edge</span><span class="p">))</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Right edge of system phase distribution: </span><span class="si">{:.0f}</span><span class="s1"> deg&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                <span class="n">right_edge</span><span class="p">))</span>

        <span class="c1"># define the system phase offset as the median value of the system</span>
        <span class="c1"># phase distriubion</span>
        <span class="n">is_system_phase</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_or</span><span class="p">(</span>
            <span class="n">phi_near_valid</span> <span class="o">&gt;=</span> <span class="n">left_edge</span><span class="p">,</span> <span class="n">phi_near_valid</span> <span class="o">&lt;=</span> <span class="n">right_edge</span><span class="p">)</span>
        <span class="n">system_phase_offset</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="n">phi_near_valid</span><span class="p">[</span><span class="n">is_system_phase</span><span class="p">])</span>

        <span class="k">if</span> <span class="n">debug</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Estimated system phase offset: </span><span class="si">{:.0f}</span><span class="s1"> deg&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                <span class="n">system_phase_offset</span><span class="p">))</span>

        <span class="k">for</span> <span class="n">ray</span><span class="p">,</span> <span class="n">bc</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">phi_near</span><span class="p">):</span>

            <span class="c1"># if near range boundary condition does not draw from system phase</span>
            <span class="c1"># distribution then set it to the system phase offset</span>
            <span class="k">if</span> <span class="n">bc</span> <span class="o">&lt;</span> <span class="n">left_edge</span> <span class="ow">or</span> <span class="n">bc</span> <span class="o">&gt;</span> <span class="n">right_edge</span><span class="p">:</span>
                <span class="n">phi_near</span><span class="p">[</span><span class="n">ray</span><span class="p">]</span> <span class="o">=</span> <span class="n">system_phase_offset</span>

    <span class="c1"># check for unphysical boundary conditions, i.e., propagation differential</span>
    <span class="c1"># phase should monotonically increase from the near boundary to the far</span>
    <span class="c1"># boundary</span>
    <span class="n">is_unphysical</span> <span class="o">=</span> <span class="n">phi_far</span> <span class="o">-</span> <span class="n">phi_near</span> <span class="o">&lt;</span> <span class="mf">0.0</span>
    <span class="n">phi_far</span><span class="p">[</span><span class="n">is_unphysical</span><span class="p">]</span> <span class="o">=</span> <span class="n">phi_near</span><span class="p">[</span><span class="n">is_unphysical</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="n">N</span> <span class="o">=</span> <span class="n">is_unphysical</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Rays with unphysical boundary conditions: </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">N</span><span class="p">))</span>

    <span class="k">return</span> <span class="n">phi_near</span><span class="p">,</span> <span class="n">phi_far</span><span class="p">,</span> <span class="n">range_near</span><span class="p">,</span> <span class="n">range_far</span><span class="p">,</span> <span class="n">idx_near</span><span class="p">,</span> <span class="n">idx_far</span>


<span class="k">def</span> <span class="nf">_cost_maesaka</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">psidp_o</span><span class="p">,</span> <span class="n">bcs</span><span class="p">,</span> <span class="n">dhv</span><span class="p">,</span> <span class="n">dr</span><span class="p">,</span> <span class="n">Cobs</span><span class="p">,</span> <span class="n">Clpf</span><span class="p">,</span> <span class="n">finite_order</span><span class="p">,</span>
                  <span class="n">fill_value</span><span class="p">,</span> <span class="n">proc</span><span class="p">,</span> <span class="n">debug</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compute the value of the cost functional similar to equations (12)-(15) in</span>
<span class="sd">    Maesaka et al. (2012).</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x : ndarray</span>
<span class="sd">        Analysis vector containing control variable k.</span>
<span class="sd">    psidp_o : ndarray</span>
<span class="sd">        Total differential phase measurements.</span>
<span class="sd">    bcs : array_like</span>
<span class="sd">        The near and far range gate propagation differential phase boundary</span>
<span class="sd">        conditions.</span>
<span class="sd">    dhv : ndarray</span>
<span class="sd">        Backscatter differential phase.</span>
<span class="sd">    dr : float</span>
<span class="sd">        Range resolution in meters.</span>
<span class="sd">    Cobs : ndarray</span>
<span class="sd">        The differential phase measurement constraint weights. The weight</span>
<span class="sd">        should vanish where no differential phase measurements are available.</span>
<span class="sd">    Clpf : float</span>
<span class="sd">        The low-pass filter (radial smoothness) constraint weight as in</span>
<span class="sd">        equation (15) of Maesaka et al. (2012).</span>
<span class="sd">    finite_order : &#39;low&#39; or &#39;high&#39;</span>
<span class="sd">        The finite difference accuracy to use when computing derivatives.</span>
<span class="sd">    fill_value : float</span>
<span class="sd">        Value indicating missing or bad data in radar field data.</span>
<span class="sd">    proc : int</span>
<span class="sd">        The number of parallel threads (CPUs) to use.</span>
<span class="sd">    debug : bool, optional</span>
<span class="sd">        True to print debugging information, False to suppress.</span>
<span class="sd">    verbose : bool, optional</span>
<span class="sd">        True to print progress information, False to suppress.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    J : float</span>
<span class="sd">        Value of total cost functional.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># parse control variable k from analysis vector</span>
    <span class="n">nr</span><span class="p">,</span> <span class="n">ng</span> <span class="o">=</span> <span class="n">psidp_o</span><span class="o">.</span><span class="n">shape</span>
    <span class="n">k</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">nr</span><span class="p">,</span> <span class="n">ng</span><span class="p">)</span>

    <span class="c1"># parse near and far range gate boundary conditions</span>
    <span class="n">phi_near</span><span class="p">,</span> <span class="n">phi_far</span> <span class="o">=</span> <span class="n">bcs</span>

    <span class="c1"># compute forward direction propagation differential phase from control</span>
    <span class="c1"># variable k</span>
    <span class="n">phi_fa</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">subok</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    <span class="n">phi_fa</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cumsum</span><span class="p">(</span><span class="n">k</span><span class="p">[:,</span> <span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

    <span class="c1"># compute reverse direction propagation differential phase from control</span>
    <span class="c1"># variable k</span>
    <span class="n">phi_ra</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">subok</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    <span class="n">phi_ra</span><span class="p">[:,</span> <span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cumsum</span><span class="p">(</span><span class="n">k</span><span class="p">[:,</span> <span class="p">:</span><span class="mi">0</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)[:,</span> <span class="p">::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

    <span class="c1"># compute forward and reverse propagation differential phase</span>
    <span class="c1"># from total differential phase observations</span>
    <span class="n">phi_fo</span> <span class="o">=</span> <span class="n">psidp_o</span> <span class="o">-</span> <span class="n">dhv</span> <span class="o">-</span> <span class="n">phi_near</span><span class="p">[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="n">ng</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">phi_ro</span> <span class="o">=</span> <span class="n">phi_far</span><span class="p">[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="n">ng</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="o">-</span> <span class="n">psidp_o</span> <span class="o">+</span> <span class="n">dhv</span>

    <span class="c1"># cost: forward direction differential phase observations</span>
    <span class="n">Jof</span> <span class="o">=</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">Cobs</span> <span class="o">*</span> <span class="p">(</span><span class="n">phi_fa</span> <span class="o">-</span> <span class="n">phi_fo</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>

    <span class="c1"># cost: reverse direction differential phase observations</span>
    <span class="n">Jor</span> <span class="o">=</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">Cobs</span> <span class="o">*</span> <span class="p">(</span><span class="n">phi_ra</span> <span class="o">-</span> <span class="n">phi_ro</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>

    <span class="c1"># prepare control variable k for Cython function</span>
    <span class="n">k</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ascontiguousarray</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>

    <span class="c1"># compute low-pass filter term, i.e., second order derivative of k with</span>
    <span class="c1"># respect to range</span>
    <span class="n">d2kdr2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty_like</span><span class="p">(</span><span class="n">k</span><span class="p">)</span>
    <span class="n">_kdp_proc</span><span class="o">.</span><span class="n">lowpass_maesaka_term</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">dr</span><span class="p">,</span> <span class="n">finite_order</span><span class="p">,</span> <span class="n">d2kdr2</span><span class="p">)</span>

    <span class="c1"># cost: low-pass filter, i.e., radial smoothness</span>
    <span class="n">Jlpf</span> <span class="o">=</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">Clpf</span> <span class="o">*</span> <span class="p">(</span><span class="n">d2kdr2</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>

    <span class="c1"># compute value of total cost functional</span>
    <span class="n">J</span> <span class="o">=</span> <span class="n">Jof</span> <span class="o">+</span> <span class="n">Jor</span> <span class="o">+</span> <span class="n">Jlpf</span>

    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Forward direction observation cost : </span><span class="si">{:1.3e}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">Jof</span><span class="p">))</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Reverse direction observation cost : </span><span class="si">{:1.3e}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">Jor</span><span class="p">))</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Low-pass filter cost ............. : </span><span class="si">{:1.3e}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">Jlpf</span><span class="p">))</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Total cost ....................... : </span><span class="si">{:1.3e}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">J</span><span class="p">))</span>

    <span class="k">return</span> <span class="n">J</span>


<span class="k">def</span> <span class="nf">_jac_maesaka</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">psidp_o</span><span class="p">,</span> <span class="n">bcs</span><span class="p">,</span> <span class="n">dhv</span><span class="p">,</span> <span class="n">dr</span><span class="p">,</span> <span class="n">Cobs</span><span class="p">,</span> <span class="n">Clpf</span><span class="p">,</span> <span class="n">finite_order</span><span class="p">,</span>
                 <span class="n">fill_value</span><span class="p">,</span> <span class="n">proc</span><span class="p">,</span> <span class="n">debug</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compute the Jacobian (gradient) of the cost functional similar to equations</span>
<span class="sd">    (16)-(18) in Maesaka et al. (2012).</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x : ndarray</span>
<span class="sd">        Analysis vector containing control variable k.</span>
<span class="sd">    psidp_o : ndarray</span>
<span class="sd">        Total differential phase measurements.</span>
<span class="sd">    bcs : array_like</span>
<span class="sd">        The near and far range gate propagation differential phase boundary</span>
<span class="sd">        conditions.</span>
<span class="sd">    dhv : ndarray</span>
<span class="sd">        Backscatter differential phase.</span>
<span class="sd">    dr : float</span>
<span class="sd">        Range resolution in meters.</span>
<span class="sd">    Cobs : ndarray</span>
<span class="sd">        The differential phase measurement constraint weights. The weight</span>
<span class="sd">        should vanish where no differential phase measurements are available.</span>
<span class="sd">    Clpf : float</span>
<span class="sd">        The low-pass filter (radial smoothness) constraint weight as in</span>
<span class="sd">        equation (15) of Maesaka et al. (2012).</span>
<span class="sd">    finite_order : &#39;low&#39; or &#39;high&#39;</span>
<span class="sd">        The finite difference accuracy to use when computing derivatives.</span>
<span class="sd">    fill_value : float</span>
<span class="sd">        Value indicating missing or bad data in radar field data.</span>
<span class="sd">    proc : int</span>
<span class="sd">        The number of parallel threads (CPUs) to use.</span>
<span class="sd">    debug : bool, optional</span>
<span class="sd">        True to print debugging information, False to suppress.</span>
<span class="sd">    verbose : bool, optional</span>
<span class="sd">        True to print progress information, False to suppress.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    jac : ndarray</span>
<span class="sd">        Jacobian of the cost functional.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># parse control variable k from analysis vector</span>
    <span class="n">nr</span><span class="p">,</span> <span class="n">ng</span> <span class="o">=</span> <span class="n">psidp_o</span><span class="o">.</span><span class="n">shape</span>
    <span class="n">k</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">nr</span><span class="p">,</span> <span class="n">ng</span><span class="p">)</span>

    <span class="c1"># parse near and far range gate boundary conditions</span>
    <span class="n">phi_near</span><span class="p">,</span> <span class="n">phi_far</span> <span class="o">=</span> <span class="n">bcs</span>

    <span class="c1"># compute forward direction propagation differential phase from control</span>
    <span class="c1"># variable k</span>
    <span class="n">phi_fa</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">subok</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    <span class="n">phi_fa</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cumsum</span><span class="p">(</span><span class="n">k</span><span class="p">[:,</span> <span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

    <span class="c1"># compute reverse direction propagation differential phase from control</span>
    <span class="c1"># variable k</span>
    <span class="n">phi_ra</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">subok</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    <span class="n">phi_ra</span><span class="p">[:,</span> <span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cumsum</span><span class="p">(</span><span class="n">k</span><span class="p">[:,</span> <span class="p">:</span><span class="mi">0</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)[:,</span> <span class="p">::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

    <span class="c1"># compute forward and reverse propagation differential phase</span>
    <span class="c1"># from total differential phase observations</span>
    <span class="n">phi_fo</span> <span class="o">=</span> <span class="n">psidp_o</span> <span class="o">-</span> <span class="n">dhv</span> <span class="o">-</span> <span class="n">phi_near</span><span class="p">[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="n">ng</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">phi_ro</span> <span class="o">=</span> <span class="n">phi_far</span><span class="p">[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="n">ng</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="o">-</span> <span class="n">psidp_o</span> <span class="o">+</span> <span class="n">dhv</span>

    <span class="c1"># prepare control variable k for Cython functions</span>
    <span class="n">k</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ascontiguousarray</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>

    <span class="c1"># cost: forward direction differential phase observations</span>
    <span class="n">dJofdk</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">subok</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    <span class="n">dJofdk</span><span class="p">[:,</span> <span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mf">2.0</span> <span class="o">*</span> <span class="n">k</span><span class="p">[:,</span> <span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">cumsum</span><span class="p">(</span>
        <span class="p">(</span><span class="n">Cobs</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">:]</span> <span class="o">*</span> <span class="p">(</span><span class="n">phi_fa</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">:]</span> <span class="o">-</span> <span class="n">phi_fo</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">:]))[:,</span> <span class="p">::</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span>
        <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)[:,</span> <span class="p">::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

    <span class="c1"># cost: reverse direction differential phase observations</span>
    <span class="n">dJordk</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">subok</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    <span class="n">dJordk</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">:]</span> <span class="o">=</span> <span class="mf">2.0</span> <span class="o">*</span> <span class="n">k</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">:]</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">cumsum</span><span class="p">(</span>
        <span class="p">(</span><span class="n">Cobs</span><span class="p">[:,</span> <span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="n">phi_ra</span><span class="p">[:,</span> <span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">phi_ro</span><span class="p">[:,</span> <span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">])),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

    <span class="c1"># compute low-pass filter term, i.e., second order derivative of k with</span>
    <span class="c1"># respect to range</span>
    <span class="n">d2kdr2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty_like</span><span class="p">(</span><span class="n">k</span><span class="p">)</span>
    <span class="n">_kdp_proc</span><span class="o">.</span><span class="n">lowpass_maesaka_term</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">dr</span><span class="p">,</span> <span class="n">finite_order</span><span class="p">,</span> <span class="n">d2kdr2</span><span class="p">)</span>

    <span class="c1"># compute gradients of Jlpf with respect to the control variable k</span>
    <span class="n">dJlpfdk</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty_like</span><span class="p">(</span><span class="n">d2kdr2</span><span class="p">)</span>
    <span class="n">_kdp_proc</span><span class="o">.</span><span class="n">lowpass_maesaka_jac</span><span class="p">(</span><span class="n">d2kdr2</span><span class="p">,</span> <span class="n">dr</span><span class="p">,</span> <span class="n">Clpf</span><span class="p">,</span> <span class="n">finite_order</span><span class="p">,</span> <span class="n">dJlpfdk</span><span class="p">)</span>

    <span class="c1"># sum control variable derivative components</span>
    <span class="n">dJdk</span> <span class="o">=</span> <span class="n">dJofdk</span> <span class="o">+</span> <span class="n">dJordk</span> <span class="o">+</span> <span class="n">dJlpfdk</span>
    <span class="n">jac</span> <span class="o">=</span> <span class="n">dJdk</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>

    <span class="c1"># compute the vector norm of the Jacobian</span>
    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="n">mag</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">jac</span><span class="p">,</span> <span class="nb">ord</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Vector norm of Jacobian: </span><span class="si">{:1.3e}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">mag</span><span class="p">))</span>

    <span class="k">return</span> <span class="n">jac</span>


<span class="k">def</span> <span class="nf">_forward_reverse_phidp</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">bcs</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compute the forward and reverse direction propagation differential phases</span>
<span class="sd">    from the control variable k and boundary conditions following equations (1)</span>
<span class="sd">    and (7) in Maesaka et al. (2012).</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    k : ndarray</span>
<span class="sd">        Control variable k of the Maesaka et al. (2012) method. The control</span>
<span class="sd">        variable k is proportional to the square root of specific differential</span>
<span class="sd">        phase.</span>
<span class="sd">    bcs : array_like</span>
<span class="sd">        The near and far range gate boundary conditions.</span>
<span class="sd">    verbose : bool, optional</span>
<span class="sd">        True to print relevant information, False to suppress.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    phidp_f : ndarray</span>
<span class="sd">        Forward direction propagation differential phase.</span>
<span class="sd">    phidp_r : ndarray</span>
<span class="sd">        Reverse direction propagation differential phase.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># parse near and far range gate boundary conditions</span>
    <span class="n">_</span><span class="p">,</span> <span class="n">ng</span> <span class="o">=</span> <span class="n">k</span><span class="o">.</span><span class="n">shape</span>
    <span class="n">phi_near</span><span class="p">,</span> <span class="n">phi_far</span> <span class="o">=</span> <span class="n">bcs</span>

    <span class="c1"># compute forward direction propagation differential phase</span>
    <span class="n">phi_f</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">subok</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    <span class="n">phi_f</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cumsum</span><span class="p">(</span><span class="n">k</span><span class="p">[:,</span> <span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">phidp_f</span> <span class="o">=</span> <span class="n">phi_f</span> <span class="o">+</span> <span class="n">phi_near</span><span class="p">[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="n">ng</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

    <span class="c1"># compute reverse direction propagation differential phase</span>
    <span class="n">phi_r</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">subok</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    <span class="n">phi_r</span><span class="p">[:,</span> <span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cumsum</span><span class="p">(</span><span class="n">k</span><span class="p">[:,</span> <span class="p">:</span><span class="mi">0</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)[:,</span> <span class="p">::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">phidp_r</span> <span class="o">=</span> <span class="n">phi_far</span><span class="p">[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="n">ng</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="o">-</span> <span class="n">phi_r</span>

    <span class="c1"># check quality of retrieval by comparing forward and reverse directions</span>
    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="n">phidp_mbe</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">phidp_f</span> <span class="o">-</span> <span class="n">phidp_r</span><span class="p">)</span>
        <span class="n">phidp_mae</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">phidp_f</span> <span class="o">-</span> <span class="n">phidp_r</span><span class="p">))</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Forward-reverse PHIDP MBE: </span><span class="si">{:.2f}</span><span class="s1"> deg&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">phidp_mbe</span><span class="p">))</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Forward-reverse PHIDP MAE: </span><span class="si">{:.2f}</span><span class="s1"> deg&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">phidp_mae</span><span class="p">))</span>

    <span class="k">return</span> <span class="n">phidp_f</span><span class="p">,</span> <span class="n">phidp_r</span>


<span class="k">def</span> <span class="nf">_parse_range_resolution</span><span class="p">(</span>
        <span class="n">radar</span><span class="p">,</span> <span class="n">check_uniform</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">atol</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Parse the radar range gate resolution.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    radar : Radar</span>
<span class="sd">        Radar containing range data.</span>
<span class="sd">    check_uniform : bool, optional</span>
<span class="sd">        True to check if all range gates are equally spaced, and if so return</span>
<span class="sd">        a scalar value for range resolution. If False, the resolution between</span>
<span class="sd">        each range gate is returned.</span>
<span class="sd">    atol : float, optional</span>
<span class="sd">        The absolute tolerance in meters allowed for discrepancies in range</span>
<span class="sd">        gate spacings. Only applicable when check_uniform is True. This</span>
<span class="sd">        parameter may be necessary to catch instances where range gate spacings</span>
<span class="sd">        differ by a few meters or so.</span>
<span class="sd">    verbose : bool, optional</span>
<span class="sd">        True to print the range gate resolution. Only valid if check_uniform is</span>
<span class="sd">        True.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    dr : float or ndarray</span>
<span class="sd">        The radar range gate spacing in meters.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># parse radar range gate spacings</span>
    <span class="n">dr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">radar</span><span class="o">.</span><span class="n">range</span><span class="p">[</span><span class="s1">&#39;data&#39;</span><span class="p">],</span> <span class="n">n</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

    <span class="c1"># check for uniform resolution</span>
    <span class="k">if</span> <span class="n">check_uniform</span> <span class="ow">and</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">dr</span><span class="p">),</span> <span class="mf">0.0</span><span class="p">,</span> <span class="n">atol</span><span class="o">=</span><span class="n">atol</span><span class="p">):</span>
        <span class="n">dr</span> <span class="o">=</span> <span class="n">dr</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Range resolution: </span><span class="si">{:.2f}</span><span class="s1"> m&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">dr</span><span class="p">))</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Radar gate spacing is not uniform&#39;</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">dr</span>
</pre></div>
<div class="section">
   
</div>

              </div>
              
              
              <!-- Previous / next buttons -->
<div class='prev-next-area'>
</div>
              
          </main>
          

      </div>
    </div>
  
  <!-- Scripts loaded after <body> so the DOM is not blocked -->
  <script src="../../../_static/scripts/pydata-sphinx-theme.js?digest=1999514e3f237ded88cf"></script>
<footer class="footer mt-5 mt-md-0">
  <div class="container">
    
    <div class="footer-item">
      <p class="copyright">
    &copy; Copyright 2013-2022, Py-ART developers.<br>
</p>
    </div>
    
    <div class="footer-item">
      <p class="sphinx-version">
Created using <a href="http://sphinx-doc.org/">Sphinx</a> 4.5.0.<br>
</p>
    </div>
    
  </div>
</footer>
  </body>
</html>